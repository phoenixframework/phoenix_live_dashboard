{
  "version": 3,
  "sources": ["../../assets/node_modules/nprogress/nprogress.js", "../../assets/js/app.js", "../../assets/js/metrics_live/color_wheel.js", "../../assets/node_modules/uplot/dist/uPlot.esm.js", "../../assets/js/metrics_live/histogram.js", "../../assets/js/metrics_live/index.js", "../../assets/js/request_logger_cookie/index.js", "../../assets/js/request_logger_query_parameter/index.js", "../../assets/js/request_logger_messages/index.js", "../../assets/js/color_bar_highlight/index.js", "../../assets/js/refresh/index.js", "../../assets/js/remember_refresh/index.js"],
  "sourcesContent": ["/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.NProgress = factory();\n  }\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n", "// Note: Phoenix JS dependencies are loaded\n// from their Application directories by the Assets module\nimport NProgress from \"nprogress\"\nimport PhxChartComponent from \"./metrics_live\"\nimport PhxRequestLoggerCookie from \"./request_logger_cookie\"\nimport PhxRequestLoggerQueryParameter from \"./request_logger_query_parameter\"\nimport PhxRequestLoggerMessages from \"./request_logger_messages\"\nimport PhxColorBarHighlight from \"./color_bar_highlight\"\nimport PhxRememberRefresh from \"./remember_refresh\"\nimport { loadRefreshData } from \"./refresh\";\n\nlet Hooks = {\n  PhxChartComponent: PhxChartComponent,\n  PhxRequestLoggerCookie: PhxRequestLoggerCookie,\n  PhxRequestLoggerQueryParameter: PhxRequestLoggerQueryParameter,\n  PhxRequestLoggerMessages: PhxRequestLoggerMessages,\n  PhxColorBarHighlight: PhxColorBarHighlight,\n  PhxRememberRefresh: PhxRememberRefresh\n}\n\nlet socketPath = document.querySelector(\"html\").getAttribute(\"phx-socket\") || \"/live\"\nlet csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\")\nlet liveSocket = new LiveView.LiveSocket(socketPath, Phoenix.Socket, {\n  hooks: Hooks,\n  params: (liveViewName) => {\n    return {\n      _csrf_token: csrfToken,\n      // Pass the most recent refresh data to the LiveView in `connect_params`\n      refresh_data: loadRefreshData(),\n    };\n  },\n})\n\n\nconst socket = liveSocket.socket\nconst originalOnConnError = socket.onConnError\nlet fallbackToLongPoll = true\n\nsocket.onOpen(() => {\n  fallbackToLongPoll = false\n})\n\nsocket.onConnError = (...args) => {\n  if (fallbackToLongPoll) {\n    // No longer fallback to longpoll\n    fallbackToLongPoll = false\n    // close the socket with an error code\n    socket.disconnect(null, 3000)\n    // fall back to long poll\n    socket.transport = Phoenix.LongPoll\n    // reopen\n    socket.connect()\n  } else {\n    originalOnConnError.apply(socket, args)\n  }\n}\n\n// Show progress bar on live navigation and form submits\nwindow.addEventListener(\"phx:page-loading-start\", info => NProgress.start())\nwindow.addEventListener(\"phx:page-loading-stop\", info => NProgress.done())\n\n// connect if there are any LiveViews on the page\nliveSocket.connect()\n\n// expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)\nwindow.liveSocket = liveSocket\n", "const COLORS = {\n  phoenix: [242, 110, 64],\n  elixir: [75, 68, 115],\n  red: [255, 99, 132],\n  orange: [255, 159, 64],\n  yellow: [255, 205, 86],\n  green: [75, 192, 192],\n  blue: [54, 162, 253],\n  purple: [153, 102, 255],\n  grey: [201, 203, 207],\n}\n\nconst COLOR_NAMES = Object.keys(COLORS)\n\nexport const ColorWheel = {\n  at: (i) => {\n    const [r, g, b] = ColorWheel.rgb(i)\n    return `rgb(${r}, ${g}, ${b})`\n  },\n  rgb: (i) => COLORS[COLOR_NAMES[i % COLOR_NAMES.length]],\n}\n\nexport const LineColor = {\n  at: (i) => {\n    const [r, g, b] = ColorWheel.rgb(i)\n    return {\n      stroke: `rgb(${r}, ${g}, ${b})`,\n      fill: `rgb(${r}, ${g}, ${b}, 0.1)`\n    }\n  }\n}\n\nexport default ColorWheel\n", "/**\n* Copyright (c) 2022, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uPlot.js (\u03BCPlot)\n* A small, fast chart for time series, lines, areas, ohlc & bars\n* https://github.com/leeoniya/uPlot (v1.6.22)\n*/\n\nconst FEAT_TIME          = true;\n\nconst pre = \"u-\";\n\nconst UPLOT          =       \"uplot\";\nconst ORI_HZ         = pre + \"hz\";\nconst ORI_VT         = pre + \"vt\";\nconst TITLE          = pre + \"title\";\nconst WRAP           = pre + \"wrap\";\nconst UNDER          = pre + \"under\";\nconst OVER           = pre + \"over\";\nconst AXIS           = pre + \"axis\";\nconst OFF            = pre + \"off\";\nconst SELECT         = pre + \"select\";\nconst CURSOR_X       = pre + \"cursor-x\";\nconst CURSOR_Y       = pre + \"cursor-y\";\nconst CURSOR_PT      = pre + \"cursor-pt\";\nconst LEGEND         = pre + \"legend\";\nconst LEGEND_LIVE    = pre + \"live\";\nconst LEGEND_INLINE  = pre + \"inline\";\nconst LEGEND_THEAD   = pre + \"thead\";\nconst LEGEND_SERIES  = pre + \"series\";\nconst LEGEND_MARKER  = pre + \"marker\";\nconst LEGEND_LABEL   = pre + \"label\";\nconst LEGEND_VALUE   = pre + \"value\";\n\nconst WIDTH       = \"width\";\nconst HEIGHT      = \"height\";\nconst TOP         = \"top\";\nconst BOTTOM      = \"bottom\";\nconst LEFT        = \"left\";\nconst RIGHT       = \"right\";\nconst hexBlack    = \"#000\";\nconst transparent = hexBlack + \"0\";\n\nconst mousemove   = \"mousemove\";\nconst mousedown   = \"mousedown\";\nconst mouseup     = \"mouseup\";\nconst mouseenter  = \"mouseenter\";\nconst mouseleave  = \"mouseleave\";\nconst dblclick    = \"dblclick\";\nconst resize      = \"resize\";\nconst scroll      = \"scroll\";\n\nconst change      = \"change\";\nconst dppxchange  = \"dppxchange\";\n\nconst domEnv = typeof window != 'undefined';\n\nconst doc = domEnv ? document  : null;\nconst win = domEnv ? window    : null;\nconst nav = domEnv ? navigator : null;\n\nlet pxRatio;\n\nlet query;\n\nfunction setPxRatio() {\n\tlet _pxRatio = devicePixelRatio;\n\n\t// during print preview, Chrome fires off these dppx queries even without changes\n\tif (pxRatio != _pxRatio) {\n\t\tpxRatio = _pxRatio;\n\n\t\tquery && off(change, query, setPxRatio);\n\t\tquery = matchMedia(`(min-resolution: ${pxRatio - 0.001}dppx) and (max-resolution: ${pxRatio + 0.001}dppx)`);\n\t\ton(change, query, setPxRatio);\n\n\t\twin.dispatchEvent(new CustomEvent(dppxchange));\n\t}\n}\n\nfunction addClass(el, c) {\n\tif (c != null) {\n\t\tlet cl = el.classList;\n\t\t!cl.contains(c) && cl.add(c);\n\t}\n}\n\nfunction remClass(el, c) {\n\tlet cl = el.classList;\n\tcl.contains(c) && cl.remove(c);\n}\n\nfunction setStylePx(el, name, value) {\n\tel.style[name] = value + \"px\";\n}\n\nfunction placeTag(tag, cls, targ, refEl) {\n\tlet el = doc.createElement(tag);\n\n\tif (cls != null)\n\t\taddClass(el, cls);\n\n\tif (targ != null)\n\t\ttarg.insertBefore(el, refEl);\n\n\treturn el;\n}\n\nfunction placeDiv(cls, targ) {\n\treturn placeTag(\"div\", cls, targ);\n}\n\nconst xformCache = new WeakMap();\n\nfunction elTrans(el, xPos, yPos, xMax, yMax) {\n\tlet xform = \"translate(\" + xPos + \"px,\" + yPos + \"px)\";\n\tlet xformOld = xformCache.get(el);\n\n\tif (xform != xformOld) {\n\t\tel.style.transform = xform;\n\t\txformCache.set(el, xform);\n\n\t\tif (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)\n\t\t\taddClass(el, OFF);\n\t\telse\n\t\t\tremClass(el, OFF);\n\t}\n}\n\nconst colorCache = new WeakMap();\n\nfunction elColor(el, background, borderColor) {\n\tlet newColor = background + borderColor;\n\tlet oldColor = colorCache.get(el);\n\n\tif (newColor != oldColor) {\n\t\tcolorCache.set(el, newColor);\n\t\tel.style.background = background;\n\t\tel.style.borderColor = borderColor;\n\t}\n}\n\nconst sizeCache = new WeakMap();\n\nfunction elSize(el, newWid, newHgt, centered) {\n\tlet newSize = newWid + \"\" + newHgt;\n\tlet oldSize = sizeCache.get(el);\n\n\tif (newSize != oldSize) {\n\t\tsizeCache.set(el, newSize);\n\t\tel.style.height = newHgt + \"px\";\n\t\tel.style.width = newWid + \"px\";\n\t\tel.style.marginLeft = centered ? -newWid/2 + \"px\" : 0;\n\t\tel.style.marginTop = centered ? -newHgt/2 + \"px\" : 0;\n\t}\n}\n\nconst evOpts = {passive: true};\nconst evOpts2 = {...evOpts, capture: true};\n\nfunction on(ev, el, cb, capt) {\n\tel.addEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\nfunction off(ev, el, cb, capt) {\n\tel.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\ndomEnv && setPxRatio();\n\n// binary search for index of closest value\nfunction closestIdx(num, arr, lo, hi) {\n\tlet mid;\n\tlo = lo || 0;\n\thi = hi || arr.length - 1;\n\tlet bitwise = hi <= 2147483647;\n\n\twhile (hi - lo > 1) {\n\t\tmid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);\n\n\t\tif (arr[mid] < num)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\n\tif (num - arr[lo] <= arr[hi] - num)\n\t\treturn lo;\n\n\treturn hi;\n}\n\nfunction nonNullIdx(data, _i0, _i1, dir) {\n\tfor (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {\n\t\tif (data[i] != null)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nfunction getMinMax(data, _i0, _i1, sorted) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tif (sorted == 1) {\n\t\t_min = data[_i0];\n\t\t_max = data[_i1];\n\t}\n\telse if (sorted == -1) {\n\t\t_min = data[_i1];\n\t\t_max = data[_i0];\n\t}\n\telse {\n\t\tfor (let i = _i0; i <= _i1; i++) {\n\t\t\tif (data[i] != null) {\n\t\t\t\t_min = min(_min, data[i]);\n\t\t\t\t_max = max(_max, data[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [_min, _max];\n}\n\nfunction getMinMaxLog(data, _i0, _i1) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tfor (let i = _i0; i <= _i1; i++) {\n\t\tif (data[i] > 0) {\n\t\t\t_min = min(_min, data[i]);\n\t\t\t_max = max(_max, data[i]);\n\t\t}\n\t}\n\n\treturn [\n\t\t_min ==  inf ?  1 : _min,\n\t\t_max == -inf ? 10 : _max,\n\t];\n}\n\nconst _fixedTuple = [0, 0];\n\nfunction fixIncr(minIncr, maxIncr, minExp, maxExp) {\n\t_fixedTuple[0] = minExp < 0 ? roundDec(minIncr, -minExp) : minIncr;\n\t_fixedTuple[1] = maxExp < 0 ? roundDec(maxIncr, -maxExp) : maxIncr;\n\treturn _fixedTuple;\n}\n\nfunction rangeLog(min, max, base, fullMags) {\n\tlet minSign = sign(min);\n\n\tlet logFn = base == 10 ? log10 : log2;\n\n\tif (min == max) {\n\t\tif (minSign == -1) {\n\t\t\tmin *= base;\n\t\t\tmax /= base;\n\t\t}\n\t\telse {\n\t\t\tmin /= base;\n\t\t\tmax *= base;\n\t\t}\n\t}\n\n\tlet minExp, maxExp, minMaxIncrs;\n\n\tif (fullMags) {\n\t\tminExp = floor(logFn(min));\n\t\tmaxExp =  ceil(logFn(max));\n\n\t\tminMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);\n\n\t\tmin = minMaxIncrs[0];\n\t\tmax = minMaxIncrs[1];\n\t}\n\telse {\n\t\tminExp = floor(logFn(abs(min)));\n\t\tmaxExp = floor(logFn(abs(max)));\n\n\t\tminMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);\n\n\t\tmin = incrRoundDn(min, minMaxIncrs[0]);\n\t\tmax = incrRoundUp(max, minMaxIncrs[1]);\n\t}\n\n\treturn [min, max];\n}\n\nfunction rangeAsinh(min, max, base, fullMags) {\n\tlet minMax = rangeLog(min, max, base, fullMags);\n\n\tif (min == 0)\n\t\tminMax[0] = 0;\n\n\tif (max == 0)\n\t\tminMax[1] = 0;\n\n\treturn minMax;\n}\n\nconst rangePad = 0.1;\n\nconst autoRangePart = {\n\tmode: 3,\n\tpad: rangePad,\n};\n\nconst _eqRangePart = {\n\tpad:  0,\n\tsoft: null,\n\tmode: 0,\n};\n\nconst _eqRange = {\n\tmin: _eqRangePart,\n\tmax: _eqRangePart,\n};\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction rangeNum(_min, _max, mult, extra) {\n\tif (isObj(mult))\n\t\treturn _rangeNum(_min, _max, mult);\n\n\t_eqRangePart.pad  = mult;\n\t_eqRangePart.soft = extra ? 0 : null;\n\t_eqRangePart.mode = extra ? 3 : 0;\n\n\treturn _rangeNum(_min, _max, _eqRange);\n}\n\n// nullish coalesce\nfunction ifNull(lh, rh) {\n\treturn lh == null ? rh : lh;\n}\n\n// checks if given index range in an array contains a non-null value\n// aka a range-bounded Array.some()\nfunction hasData(data, idx0, idx1) {\n\tidx0 = ifNull(idx0, 0);\n\tidx1 = ifNull(idx1, data.length - 1);\n\n\twhile (idx0 <= idx1) {\n\t\tif (data[idx0] != null)\n\t\t\treturn true;\n\t\tidx0++;\n\t}\n\n\treturn false;\n}\n\nfunction _rangeNum(_min, _max, cfg) {\n\tlet cmin = cfg.min;\n\tlet cmax = cfg.max;\n\n\tlet padMin = ifNull(cmin.pad, 0);\n\tlet padMax = ifNull(cmax.pad, 0);\n\n\tlet hardMin = ifNull(cmin.hard, -inf);\n\tlet hardMax = ifNull(cmax.hard,  inf);\n\n\tlet softMin = ifNull(cmin.soft,  inf);\n\tlet softMax = ifNull(cmax.soft, -inf);\n\n\tlet softMinMode = ifNull(cmin.mode, 0);\n\tlet softMaxMode = ifNull(cmax.mode, 0);\n\n\tlet delta        = _max - _min;\n\n\t// this handles situations like 89.7, 89.69999999999999\n\t// by assuming 0.001x deltas are precision errors\n//\tif (delta > 0 && delta < abs(_max) / 1e3)\n//\t\tdelta = 0;\n\n\t// treat data as flat if delta is less than 1 billionth\n\tif (delta < 1e-9) {\n\t\tdelta = 0;\n\n\t\t// if soft mode is 2 and all vals are flat at 0, avoid the 0.1 * 1e3 fallback\n\t\t// this prevents 0,0,0 from ranging to -100,100 when softMin/softMax are -1,1\n\t\tif (_min == 0 || _max == 0) {\n\t\t\tdelta = 1e-9;\n\n\t\t\tif (softMinMode == 2 && softMin != inf)\n\t\t\t\tpadMin = 0;\n\n\t\t\tif (softMaxMode == 2 && softMax != -inf)\n\t\t\t\tpadMax = 0;\n\t\t}\n\t}\n\n\tlet nonZeroDelta = delta || abs(_max) || 1e3;\n\tlet mag          = log10(nonZeroDelta);\n\tlet base         = pow(10, floor(mag));\n\n\tlet _padMin  = nonZeroDelta * (delta == 0 ? (_min == 0 ? .1 : 1) : padMin);\n\tlet _newMin  = roundDec(incrRoundDn(_min - _padMin, base/10), 9);\n\tlet _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;\n\tlet minLim   = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));\n\n\tlet _padMax  = nonZeroDelta * (delta == 0 ? (_max == 0 ? .1 : 1) : padMax);\n\tlet _newMax  = roundDec(incrRoundUp(_max + _padMax, base/10), 9);\n\tlet _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;\n\tlet maxLim   = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));\n\n\tif (minLim == maxLim && minLim == 0)\n\t\tmaxLim = 100;\n\n\treturn [minLim, maxLim];\n}\n\n// alternative: https://stackoverflow.com/a/2254896\nconst numFormatter = new Intl.NumberFormat(domEnv ? nav.language : 'en-US');\nconst fmtNum = val => numFormatter.format(val);\n\nconst M = Math;\n\nconst PI = M.PI;\nconst abs = M.abs;\nconst floor = M.floor;\nconst round = M.round;\nconst ceil = M.ceil;\nconst min = M.min;\nconst max = M.max;\nconst pow = M.pow;\nconst sign = M.sign;\nconst log10 = M.log10;\nconst log2 = M.log2;\n// TODO: seems like this needs to match asinh impl if the passed v is tweaked?\nconst sinh =  (v, linthresh = 1) => M.sinh(v) * linthresh;\nconst asinh = (v, linthresh = 1) => M.asinh(v / linthresh);\n\nconst inf = Infinity;\n\nfunction numIntDigits(x) {\n\treturn (log10((x ^ (x >> 31)) - (x >> 31)) | 0) + 1;\n}\n\nfunction incrRound(num, incr) {\n\treturn round(num/incr)*incr;\n}\n\nfunction clamp(num, _min, _max) {\n\treturn min(max(num, _min), _max);\n}\n\nfunction fnOrSelf(v) {\n\treturn typeof v == \"function\" ? v : () => v;\n}\n\nconst retArg0 = _0 => _0;\n\nconst retArg1 = (_0, _1) => _1;\n\nconst retNull = _ => null;\n\nconst retTrue = _ => true;\n\nconst retEq = (a, b) => a == b;\n\nfunction incrRoundUp(num, incr) {\n\treturn ceil(num/incr)*incr;\n}\n\nfunction incrRoundDn(num, incr) {\n\treturn floor(num/incr)*incr;\n}\n\nfunction roundDec(val, dec) {\n\treturn round(val * (dec = 10**dec)) / dec;\n}\n\nconst fixedDec = new Map();\n\nfunction guessDec(num) {\n\treturn ((\"\"+num).split(\".\")[1] || \"\").length;\n}\n\nfunction genIncrs(base, minExp, maxExp, mults) {\n\tlet incrs = [];\n\n\tlet multDec = mults.map(guessDec);\n\n\tfor (let exp = minExp; exp < maxExp; exp++) {\n\t\tlet expa = abs(exp);\n\t\tlet mag = roundDec(pow(base, exp), expa);\n\n\t\tfor (let i = 0; i < mults.length; i++) {\n\t\t\tlet _incr = mults[i] * mag;\n\t\t\tlet dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);\n\t\t\tlet incr = roundDec(_incr, dec);\n\t\t\tincrs.push(incr);\n\t\t\tfixedDec.set(incr, dec);\n\t\t}\n\t}\n\n\treturn incrs;\n}\n\n//export const assign = Object.assign;\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\n\nconst nullNullTuple = [null, null];\n\nconst isArr = Array.isArray;\n\nfunction isStr(v) {\n\treturn typeof v == 'string';\n}\n\nfunction isObj(v) {\n\tlet is = false;\n\n\tif (v != null) {\n\t\tlet c = v.constructor;\n\t\tis = c == null || c == Object;\n\t}\n\n\treturn is;\n}\n\nfunction fastIsObj(v) {\n\treturn v != null && typeof v == 'object';\n}\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\nfunction copy(o, _isObj = isObj) {\n\tlet out;\n\n\tif (isArr(o)) {\n\t\tlet val = o.find(v => v != null);\n\n\t\tif (isArr(val) || _isObj(val)) {\n\t\t\tout = Array(o.length);\n\t\t\tfor (let i = 0; i < o.length; i++)\n\t\t\t\tout[i] = copy(o[i], _isObj);\n\t\t}\n\t\telse\n\t\t\tout = o.slice();\n\t}\n\telse if (o instanceof TypedArray) // also (ArrayBuffer.isView(o) && !(o instanceof DataView))\n\t\tout = o.slice();\n\telse if (_isObj(o)) {\n\t\tout = {};\n\t\tfor (let k in o)\n\t\t\tout[k] = copy(o[k], _isObj);\n\t}\n\telse\n\t\tout = o;\n\n\treturn out;\n}\n\nfunction assign(targ) {\n\tlet args = arguments;\n\n\tfor (let i = 1; i < args.length; i++) {\n\t\tlet src = args[i];\n\n\t\tfor (let key in src) {\n\t\t\tif (isObj(targ[key]))\n\t\t\t\tassign(targ[key], copy(src[key]));\n\t\t\telse\n\t\t\t\ttarg[key] = copy(src[key]);\n\t\t}\n\t}\n\n\treturn targ;\n}\n\n// nullModes\nconst NULL_REMOVE = 0;  // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1;  // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2;  // nulls are expanded to include any adjacent alignment artifacts\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals, nullIdxs, alignedLen) {\n\tfor (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n\t\tlet nullIdx = nullIdxs[i];\n\n\t\tif (nullIdx > lastNullIdx) {\n\t\t\txi = nullIdx - 1;\n\t\t\twhile (xi >= 0 && yVals[xi] == null)\n\t\t\t\tyVals[xi--] = null;\n\n\t\t\txi = nullIdx + 1;\n\t\t\twhile (xi < alignedLen && yVals[xi] == null)\n\t\t\t\tyVals[lastNullIdx = xi++] = null;\n\t\t}\n\t}\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\n// output is sorted ASC on the joined field (table[0]) and duplicate join values are collapsed\nfunction join(tables, nullModes) {\n\tlet xVals = new Set();\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\t\tlet len = xs.length;\n\n\t\tfor (let i = 0; i < len; i++)\n\t\t\txVals.add(xs[i]);\n\t}\n\n\tlet data = [Array.from(xVals).sort((a, b) => a - b)];\n\n\tlet alignedLen = data[0].length;\n\n\tlet xIdxs = new Map();\n\n\tfor (let i = 0; i < alignedLen; i++)\n\t\txIdxs.set(data[0][i], i);\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\n\t\tfor (let si = 1; si < t.length; si++) {\n\t\t\tlet ys = t[si];\n\n\t\t\tlet yVals = Array(alignedLen).fill(undefined);\n\n\t\t\tlet nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n\t\t\tlet nullIdxs = [];\n\n\t\t\tfor (let i = 0; i < ys.length; i++) {\n\t\t\t\tlet yVal = ys[i];\n\t\t\t\tlet alignedIdx = xIdxs.get(xs[i]);\n\n\t\t\t\tif (yVal === null) {\n\t\t\t\t\tif (nullMode != NULL_REMOVE) {\n\t\t\t\t\t\tyVals[alignedIdx] = yVal;\n\n\t\t\t\t\t\tif (nullMode == NULL_EXPAND)\n\t\t\t\t\t\t\tnullIdxs.push(alignedIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tyVals[alignedIdx] = yVal;\n\t\t\t}\n\n\t\t\tnullExpand(yVals, nullIdxs, alignedLen);\n\n\t\t\tdata.push(yVals);\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst microTask = typeof queueMicrotask == \"undefined\" ? fn => Promise.resolve().then(fn) : queueMicrotask;\n\nconst months = [\n\t\"January\",\n\t\"February\",\n\t\"March\",\n\t\"April\",\n\t\"May\",\n\t\"June\",\n\t\"July\",\n\t\"August\",\n\t\"September\",\n\t\"October\",\n\t\"November\",\n\t\"December\",\n];\n\nconst days = [\n\t\"Sunday\",\n\t\"Monday\",\n\t\"Tuesday\",\n\t\"Wednesday\",\n\t\"Thursday\",\n\t\"Friday\",\n\t\"Saturday\",\n];\n\nfunction slice3(str) {\n\treturn str.slice(0, 3);\n}\n\nconst days3 = days.map(slice3);\n\nconst months3 = months.map(slice3);\n\nconst engNames = {\n\tMMMM: months,\n\tMMM:  months3,\n\tWWWW: days,\n\tWWW:  days3,\n};\n\nfunction zeroPad2(int) {\n\treturn (int < 10 ? '0' : '') + int;\n}\n\nfunction zeroPad3(int) {\n\treturn (int < 10 ? '00' : int < 100 ? '0' : '') + int;\n}\n\n/*\nfunction suffix(int) {\n\tlet mod10 = int % 10;\n\n\treturn int + (\n\t\tmod10 == 1 && int != 11 ? \"st\" :\n\t\tmod10 == 2 && int != 12 ? \"nd\" :\n\t\tmod10 == 3 && int != 13 ? \"rd\" : \"th\"\n\t);\n}\n*/\n\nconst subs = {\n\t// 2019\n\tYYYY:\td => d.getFullYear(),\n\t// 19\n\tYY:\t\td => (d.getFullYear()+'').slice(2),\n\t// July\n\tMMMM:\t(d, names) => names.MMMM[d.getMonth()],\n\t// Jul\n\tMMM:\t(d, names) => names.MMM[d.getMonth()],\n\t// 07\n\tMM:\t\td => zeroPad2(d.getMonth()+1),\n\t// 7\n\tM:\t\td => d.getMonth()+1,\n\t// 09\n\tDD:\t\td => zeroPad2(d.getDate()),\n\t// 9\n\tD:\t\td => d.getDate(),\n\t// Monday\n\tWWWW:\t(d, names) => names.WWWW[d.getDay()],\n\t// Mon\n\tWWW:\t(d, names) => names.WWW[d.getDay()],\n\t// 03\n\tHH:\t\td => zeroPad2(d.getHours()),\n\t// 3\n\tH:\t\td => d.getHours(),\n\t// 9 (12hr, unpadded)\n\th:\t\td => {let h = d.getHours(); return h == 0 ? 12 : h > 12 ? h - 12 : h;},\n\t// AM\n\tAA:\t\td => d.getHours() >= 12 ? 'PM' : 'AM',\n\t// am\n\taa:\t\td => d.getHours() >= 12 ? 'pm' : 'am',\n\t// a\n\ta:\t\td => d.getHours() >= 12 ? 'p' : 'a',\n\t// 09\n\tmm:\t\td => zeroPad2(d.getMinutes()),\n\t// 9\n\tm:\t\td => d.getMinutes(),\n\t// 09\n\tss:\t\td => zeroPad2(d.getSeconds()),\n\t// 9\n\ts:\t\td => d.getSeconds(),\n\t// 374\n\tfff:\td => zeroPad3(d.getMilliseconds()),\n};\n\nfunction fmtDate(tpl, names) {\n\tnames = names || engNames;\n\tlet parts = [];\n\n\tlet R = /\\{([a-z]+)\\}|[^{]+/gi, m;\n\n\twhile (m = R.exec(tpl))\n\t\tparts.push(m[0][0] == '{' ? subs[m[1]] : m[0]);\n\n\treturn d => {\n\t\tlet out = '';\n\n\t\tfor (let i = 0; i < parts.length; i++)\n\t\t\tout += typeof parts[i] == \"string\" ? parts[i] : parts[i](d, names);\n\n\t\treturn out;\n\t}\n}\n\nconst localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n// https://stackoverflow.com/questions/15141762/how-to-initialize-a-javascript-date-to-a-particular-time-zone/53652131#53652131\nfunction tzDate(date, tz) {\n\tlet date2;\n\n\t// perf optimization\n\tif (tz == 'UTC' || tz == 'Etc/UTC')\n\t\tdate2 = new Date(+date + date.getTimezoneOffset() * 6e4);\n\telse if (tz == localTz)\n\t\tdate2 = date;\n\telse {\n\t\tdate2 = new Date(date.toLocaleString('en-US', {timeZone: tz}));\n\t\tdate2.setMilliseconds(date.getMilliseconds());\n\t}\n\n\treturn date2;\n}\n\n//export const series = [];\n\n// default formatters:\n\nconst onlyWhole = v => v % 1 == 0;\n\nconst allMults = [1,2,2.5,5];\n\n// ...0.01, 0.02, 0.025, 0.05, 0.1, 0.2, 0.25, 0.5\nconst decIncrs = genIncrs(10, -16, 0, allMults);\n\n// 1, 2, 2.5, 5, 10, 20, 25, 50...\nconst oneIncrs = genIncrs(10, 0, 16, allMults);\n\n// 1, 2,      5, 10, 20, 25, 50...\nconst wholeIncrs = oneIncrs.filter(onlyWhole);\n\nconst numIncrs = decIncrs.concat(oneIncrs);\n\nconst NL = \"\\n\";\n\nconst yyyy    = \"{YYYY}\";\nconst NLyyyy  = NL + yyyy;\nconst md      = \"{M}/{D}\";\nconst NLmd    = NL + md;\nconst NLmdyy  = NLmd + \"/{YY}\";\n\nconst aa      = \"{aa}\";\nconst hmm     = \"{h}:{mm}\";\nconst hmmaa   = hmm + aa;\nconst NLhmmaa = NL + hmmaa;\nconst ss      = \":{ss}\";\n\nconst _ = null;\n\nfunction genTimeStuffs(ms) {\n\tlet\ts  = ms * 1e3,\n\t\tm  = s  * 60,\n\t\th  = m  * 60,\n\t\td  = h  * 24,\n\t\tmo = d  * 30,\n\t\ty  = d  * 365;\n\n\t// min of 1e-3 prevents setting a temporal x ticks too small since Date objects cannot advance ticks smaller than 1ms\n\tlet subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);\n\n\tlet timeIncrs = subSecIncrs.concat([\n\t\t// minute divisors (# of secs)\n\t\ts,\n\t\ts * 5,\n\t\ts * 10,\n\t\ts * 15,\n\t\ts * 30,\n\t\t// hour divisors (# of mins)\n\t\tm,\n\t\tm * 5,\n\t\tm * 10,\n\t\tm * 15,\n\t\tm * 30,\n\t\t// day divisors (# of hrs)\n\t\th,\n\t\th * 2,\n\t\th * 3,\n\t\th * 4,\n\t\th * 6,\n\t\th * 8,\n\t\th * 12,\n\t\t// month divisors TODO: need more?\n\t\td,\n\t\td * 2,\n\t\td * 3,\n\t\td * 4,\n\t\td * 5,\n\t\td * 6,\n\t\td * 7,\n\t\td * 8,\n\t\td * 9,\n\t\td * 10,\n\t\td * 15,\n\t\t// year divisors (# months, approx)\n\t\tmo,\n\t\tmo * 2,\n\t\tmo * 3,\n\t\tmo * 4,\n\t\tmo * 6,\n\t\t// century divisors\n\t\ty,\n\t\ty * 2,\n\t\ty * 5,\n\t\ty * 10,\n\t\ty * 25,\n\t\ty * 50,\n\t\ty * 100,\n\t]);\n\n\t// [0]:   minimum num secs in the tick incr\n\t// [1]:   default tick format\n\t// [2-7]: rollover tick formats\n\t// [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]\n\tconst _timeAxisStamps = [\n\t//   tick incr    default          year                    month   day                   hour    min       sec   mode\n\t\t[y,           yyyy,            _,                      _,      _,                    _,      _,        _,       1],\n\t\t[d * 28,      \"{MMM}\",         NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[d,           md,              NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[h,           \"{h}\" + aa,      NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[m,           hmmaa,           NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[s,           ss,              NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t\t[ms,          ss + \".{fff}\",   NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t];\n\n\t// the ensures that axis ticks, values & grid are aligned to logical temporal breakpoints and not an arbitrary timestamp\n\t// https://www.timeanddate.com/time/dst/\n\t// https://www.timeanddate.com/time/dst/2019.html\n\t// https://www.epochconverter.com/timezones\n\tfunction timeAxisSplits(tzDate) {\n\t\treturn (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n\t\t\tlet splits = [];\n\t\t\tlet isYr = foundIncr >= y;\n\t\t\tlet isMo = foundIncr >= mo && foundIncr < y;\n\n\t\t\t// get the timezone-adjusted date\n\t\t\tlet minDate = tzDate(scaleMin);\n\t\t\tlet minDateTs = roundDec(minDate * ms, 3);\n\n\t\t\t// get ts of 12am (this lands us at or before the original scaleMin)\n\t\t\tlet minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());\n\t\t\tlet minMinTs = roundDec(minMin * ms, 3);\n\n\t\t\tif (isMo || isYr) {\n\t\t\t\tlet moIncr = isMo ? foundIncr / mo : 0;\n\t\t\t\tlet yrIncr = isYr ? foundIncr / y  : 0;\n\t\t\t//\tlet tzOffset = scaleMin - minDateTs;\t\t// needed?\n\t\t\t\tlet split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);\n\t\t\t\tlet splitDate = new Date(round(split / ms));\n\t\t\t\tlet baseYear = splitDate.getFullYear();\n\t\t\t\tlet baseMonth = splitDate.getMonth();\n\n\t\t\t\tfor (let i = 0; split <= scaleMax; i++) {\n\t\t\t\t\tlet next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);\n\t\t\t\t\tlet offs = next - tzDate(roundDec(next * ms, 3));\n\n\t\t\t\t\tsplit = roundDec((+next + offs) * ms, 3);\n\n\t\t\t\t\tif (split <= scaleMax)\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet incr0 = foundIncr >= d ? d : foundIncr;\n\t\t\t\tlet tzOffset = floor(scaleMin) - floor(minDateTs);\n\t\t\t\tlet split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);\n\t\t\t\tsplits.push(split);\n\n\t\t\t\tlet date0 = tzDate(split);\n\n\t\t\t\tlet prevHour = date0.getHours() + (date0.getMinutes() / m) + (date0.getSeconds() / h);\n\t\t\t\tlet incrHours = foundIncr / h;\n\n\t\t\t\tlet minSpace = self.axes[axisIdx]._space;\n\t\t\t\tlet pctSpace = foundSpace / minSpace;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tsplit = roundDec(split + foundIncr, ms == 1 ? 0 : 3);\n\n\t\t\t\t\tif (split > scaleMax)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (incrHours > 1) {\n\t\t\t\t\t\tlet expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;\n\t\t\t\t\t\tlet splitDate = tzDate(split);\n\t\t\t\t\t\tlet actualHour = splitDate.getHours();\n\n\t\t\t\t\t\tlet dstShift = actualHour - expectedHour;\n\n\t\t\t\t\t\tif (dstShift > 1)\n\t\t\t\t\t\t\tdstShift = -1;\n\n\t\t\t\t\t\tsplit -= dstShift * h;\n\n\t\t\t\t\t\tprevHour = (prevHour + incrHours) % 24;\n\n\t\t\t\t\t\t// add a tick only if it's further than 70% of the min allowed label spacing\n\t\t\t\t\t\tlet prevSplit = splits[splits.length - 1];\n\t\t\t\t\t\tlet pctIncr = roundDec((split - prevSplit) / foundIncr, 3);\n\n\t\t\t\t\t\tif (pctIncr * pctSpace >= .7)\n\t\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn splits;\n\t\t}\n\t}\n\n\treturn [\n\t\ttimeIncrs,\n\t\t_timeAxisStamps,\n\t\ttimeAxisSplits,\n\t];\n}\n\nconst [ timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs ] = genTimeStuffs(1);\nconst [ timeIncrsS,  _timeAxisStampsS,  timeAxisSplitsS  ] = genTimeStuffs(1e-3);\n\n// base 2\ngenIncrs(2, -53, 53, [1]);\n\n/*\nconsole.log({\n\tdecIncrs,\n\toneIncrs,\n\twholeIncrs,\n\tnumIncrs,\n\ttimeIncrs,\n\tfixedDec,\n});\n*/\n\nfunction timeAxisStamps(stampCfg, fmtDate) {\n\treturn stampCfg.map(s => s.map((v, i) =>\n\t\ti == 0 || i == 8 || v == null ? v : fmtDate(i == 1 || s[8] == 0 ? v : s[1] + v)\n\t));\n}\n\n// TODO: will need to accept spaces[] and pull incr into the loop when grid will be non-uniform, eg for log scales.\n// currently we ignore this for months since they're *nearly* uniform and the added complexity is not worth it\nfunction timeAxisVals(tzDate, stamps) {\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => {\n\t\tlet s = stamps.find(s => foundIncr >= s[0]) || stamps[stamps.length - 1];\n\n\t\t// these track boundaries when a full label is needed again\n\t\tlet prevYear;\n\t\tlet prevMnth;\n\t\tlet prevDate;\n\t\tlet prevHour;\n\t\tlet prevMins;\n\t\tlet prevSecs;\n\n\t\treturn splits.map(split => {\n\t\t\tlet date = tzDate(split);\n\n\t\t\tlet newYear = date.getFullYear();\n\t\t\tlet newMnth = date.getMonth();\n\t\t\tlet newDate = date.getDate();\n\t\t\tlet newHour = date.getHours();\n\t\t\tlet newMins = date.getMinutes();\n\t\t\tlet newSecs = date.getSeconds();\n\n\t\t\tlet stamp = (\n\t\t\t\tnewYear != prevYear && s[2] ||\n\t\t\t\tnewMnth != prevMnth && s[3] ||\n\t\t\t\tnewDate != prevDate && s[4] ||\n\t\t\t\tnewHour != prevHour && s[5] ||\n\t\t\t\tnewMins != prevMins && s[6] ||\n\t\t\t\tnewSecs != prevSecs && s[7] ||\n\t\t\t\t                       s[1]\n\t\t\t);\n\n\t\t\tprevYear = newYear;\n\t\t\tprevMnth = newMnth;\n\t\t\tprevDate = newDate;\n\t\t\tprevHour = newHour;\n\t\t\tprevMins = newMins;\n\t\t\tprevSecs = newSecs;\n\n\t\t\treturn stamp(date);\n\t\t});\n\t}\n}\n\n// for when axis.values is defined as a static fmtDate template string\nfunction timeAxisVal(tzDate, dateTpl) {\n\tlet stamp = fmtDate(dateTpl);\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => splits.map(split => stamp(tzDate(split)));\n}\n\nfunction mkDate(y, m, d) {\n\treturn new Date(y, m, d);\n}\n\nfunction timeSeriesStamp(stampCfg, fmtDate) {\n\treturn fmtDate(stampCfg);\n}\nconst _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';\n\nfunction timeSeriesVal(tzDate, stamp) {\n\treturn (self, val) => stamp(tzDate(val));\n}\n\nfunction legendStroke(self, seriesIdx) {\n\tlet s = self.series[seriesIdx];\n\treturn s.width ? s.stroke(self, seriesIdx) : s.points.width ? s.points.stroke(self, seriesIdx) : null;\n}\n\nfunction legendFill(self, seriesIdx) {\n\treturn self.series[seriesIdx].fill(self, seriesIdx);\n}\n\nconst legendOpts = {\n\tshow: true,\n\tlive: true,\n\tisolate: false,\n\tmarkers: {\n\t\tshow: true,\n\t\twidth: 2,\n\t\tstroke: legendStroke,\n\t\tfill: legendFill,\n\t\tdash: \"solid\",\n\t},\n\tidx: null,\n\tidxs: null,\n\tvalues: [],\n};\n\nfunction cursorPointShow(self, si) {\n\tlet o = self.cursor.points;\n\n\tlet pt = placeDiv();\n\n\tlet size = o.size(self, si);\n\tsetStylePx(pt, WIDTH, size);\n\tsetStylePx(pt, HEIGHT, size);\n\n\tlet mar = size / -2;\n\tsetStylePx(pt, \"marginLeft\", mar);\n\tsetStylePx(pt, \"marginTop\", mar);\n\n\tlet width = o.width(self, si, size);\n\twidth && setStylePx(pt, \"borderWidth\", width);\n\n\treturn pt;\n}\n\nfunction cursorPointFill(self, si) {\n\tlet sp = self.series[si].points;\n\treturn sp._fill || sp._stroke;\n}\n\nfunction cursorPointStroke(self, si) {\n\tlet sp = self.series[si].points;\n\treturn sp._stroke || sp._fill;\n}\n\nfunction cursorPointSize(self, si) {\n\tlet sp = self.series[si].points;\n\treturn ptDia(sp.width, 1);\n}\n\nfunction dataIdx(self, seriesIdx, cursorIdx) {\n\treturn cursorIdx;\n}\n\nconst moveTuple = [0,0];\n\nfunction cursorMove(self, mouseLeft1, mouseTop1) {\n\tmoveTuple[0] = mouseLeft1;\n\tmoveTuple[1] = mouseTop1;\n\treturn moveTuple;\n}\n\nfunction filtBtn0(self, targ, handle) {\n\treturn e => {\n\t\te.button == 0 && handle(e);\n\t};\n}\n\nfunction passThru(self, targ, handle) {\n\treturn handle;\n}\n\nconst cursorOpts = {\n\tshow: true,\n\tx: true,\n\ty: true,\n\tlock: false,\n\tmove: cursorMove,\n\tpoints: {\n\t\tshow:   cursorPointShow,\n\t\tsize:   cursorPointSize,\n\t\twidth:  0,\n\t\tstroke: cursorPointStroke,\n\t\tfill:   cursorPointFill,\n\t},\n\n\tbind: {\n\t\tmousedown:   filtBtn0,\n\t\tmouseup:     filtBtn0,\n\t\tclick:       filtBtn0,\n\t\tdblclick:    filtBtn0,\n\n\t\tmousemove:   passThru,\n\t\tmouseleave:  passThru,\n\t\tmouseenter:  passThru,\n\t},\n\n\tdrag: {\n\t\tsetScale: true,\n\t\tx: true,\n\t\ty: false,\n\t\tdist: 0,\n\t\tuni: null,\n\t\t_x: false,\n\t\t_y: false,\n\t},\n\n\tfocus: {\n\t\tprox: -1,\n\t},\n\n\tleft: -10,\n\ttop: -10,\n\tidx: null,\n\tdataIdx,\n\tidxs: null,\n};\n\nconst axisLines = {\n\tshow: true,\n\tstroke: \"rgba(0,0,0,0.07)\",\n\twidth: 2,\n//\tdash: [],\n};\n\nconst grid = assign({}, axisLines, {\n\tfilter: retArg1,\n});\n\nconst ticks = assign({}, grid, {\n\tsize: 10,\n});\n\nconst border = assign({}, axisLines, {\n\tshow: false,\n});\n\nconst font      = '12px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"';\nconst labelFont = \"bold \" + font;\nconst lineMult = 1.5;\t\t// font-size multiplier\n\nconst xAxisOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tstroke: hexBlack,\n\tspace: 50,\n\tgap: 5,\n\tsize: 50,\n\tlabelGap: 0,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 2,\n//\tclass: \"x-vals\",\n//\tincrs: timeIncrs,\n//\tvalues: timeVals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tborder,\n\tfont,\n\trotate: 0,\n};\n\nconst numSeriesLabel = \"Value\";\nconst timeSeriesLabel = \"Time\";\n\nconst xSeriesOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tauto: false,\n\tsorted: 1,\n//\tlabel: \"Time\",\n//\tvalue: v => stamp(new Date(v * 1e3)),\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n};\n\nfunction numAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {\n\treturn splits.map(v => v == null ? \"\" : fmtNum(v));\n}\n\nfunction numAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet splits = [];\n\n\tlet numDec = fixedDec.get(foundIncr) || 0;\n\n\tscaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);\n\n\tfor (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))\n\t\tsplits.push(Object.is(val, -0) ? 0 : val);\t\t// coalesces -0\n\n\treturn splits;\n}\n\n// this doesnt work for sin, which needs to come off from 0 independently in pos and neg dirs\nfunction logAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tconst splits = [];\n\n\tconst logBase = self.scales[self.axes[axisIdx].scale].log;\n\n\tconst logFn = logBase == 10 ? log10 : log2;\n\n\tconst exp = floor(logFn(scaleMin));\n\n\tfoundIncr = pow(logBase, exp);\n\n\tif (exp < 0)\n\t\tfoundIncr = roundDec(foundIncr, -exp);\n\n\tlet split = scaleMin;\n\n\tdo {\n\t\tsplits.push(split);\n\t\tsplit = roundDec(split + foundIncr, fixedDec.get(foundIncr));\n\n\t\tif (split >= foundIncr * logBase)\n\t\t\tfoundIncr = split;\n\n\t} while (split <= scaleMax);\n\n\treturn splits;\n}\n\nfunction asinhAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet sc = self.scales[self.axes[axisIdx].scale];\n\n\tlet linthresh = sc.asinh;\n\n\tlet posSplits = scaleMax > linthresh ? logAxisSplits(self, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];\n\tlet zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];\n\tlet negSplits = scaleMin < -linthresh ? logAxisSplits(self, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr): [linthresh];\n\n\treturn negSplits.reverse().map(v => -v).concat(zero, posSplits);\n}\n\nconst RE_ALL   = /./;\nconst RE_12357 = /[12357]/;\nconst RE_125   = /[125]/;\nconst RE_1     = /1/;\n\nfunction logAxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {\n\tlet axis = self.axes[axisIdx];\n\tlet scaleKey = axis.scale;\n\tlet sc = self.scales[scaleKey];\n\n\tif (sc.distr == 3 && sc.log == 2)\n\t\treturn splits;\n\n\tlet valToPos = self.valToPos;\n\n\tlet minSpace = axis._space;\n\n\tlet _10 = valToPos(10, scaleKey);\n\n\tlet re = (\n\t\tvalToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL :\n\t\tvalToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 :\n\t\tvalToPos(5, scaleKey) - _10 >= minSpace ? RE_125 :\n\t\tRE_1\n\t);\n\n\treturn splits.map(v => ((sc.distr == 4 && v == 0) || re.test(v)) ? v : null);\n}\n\nfunction numSeriesVal(self, val) {\n\treturn val == null ? \"\" : fmtNum(val);\n}\n\nconst yAxisOpts = {\n\tshow: true,\n\tscale: \"y\",\n\tstroke: hexBlack,\n\tspace: 30,\n\tgap: 5,\n\tsize: 50,\n\tlabelGap: 0,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 3,\n//\tclass: \"y-vals\",\n//\tincrs: numIncrs,\n//\tvalues: (vals, space) => vals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tborder,\n\tfont,\n\trotate: 0,\n};\n\n// takes stroke width\nfunction ptDia(width, mult) {\n\tlet dia = 3 + (width || 1) * 2;\n\treturn roundDec(dia * mult, 3);\n}\n\nfunction seriesPointsShow(self, si) {\n\tlet { scale, idxs } = self.series[0];\n\tlet xData = self._data[0];\n\tlet p0 = self.valToPos(xData[idxs[0]], scale, true);\n\tlet p1 = self.valToPos(xData[idxs[1]], scale, true);\n\tlet dim = abs(p1 - p0);\n\n\tlet s = self.series[si];\n//\tconst dia = ptDia(s.width, pxRatio);\n\tlet maxPts = dim / (s.points.space * pxRatio);\n\treturn idxs[1] - idxs[0] <= maxPts;\n}\n\nconst facet = {\n\tscale: null,\n\tauto: true,\n\tsorted: 0,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n};\n\nconst xySeriesOpts = {\n\tshow: true,\n\tauto: true,\n\tsorted: 0,\n\talpha: 1,\n\tfacets: [\n\t\tassign({}, facet, {scale: 'x'}),\n\t\tassign({}, facet, {scale: 'y'}),\n\t],\n};\n\nconst ySeriesOpts = {\n\tscale: \"y\",\n\tauto: true,\n\tsorted: 0,\n\tshow: true,\n\tspanGaps: false,\n\tgaps: (self, seriesIdx, idx0, idx1, nullGaps) => nullGaps,\n\talpha: 1,\n\tpoints: {\n\t\tshow: seriesPointsShow,\n\t\tfilter: null,\n\t//  paths:\n\t//\tstroke: \"#000\",\n\t//\tfill: \"#fff\",\n\t//\twidth: 1,\n\t//\tsize: 10,\n\t},\n//\tlabel: \"Value\",\n//\tvalue: v => v,\n\tvalues: null,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n\n\tpath: null,\n\tclip: null,\n};\n\nfunction clampScale(self, val, scaleMin, scaleMax, scaleKey) {\n/*\n\tif (val < 0) {\n\t\tlet cssHgt = self.bbox.height / pxRatio;\n\t\tlet absPos = self.valToPos(abs(val), scaleKey);\n\t\tlet fromBtm = cssHgt - absPos;\n\t\treturn self.posToVal(cssHgt + fromBtm, scaleKey);\n\t}\n*/\n\treturn scaleMin / 10;\n}\n\nconst xScaleOpts = {\n\ttime: FEAT_TIME,\n\tauto: true,\n\tdistr: 1,\n\tlog: 10,\n\tasinh: 1,\n\tmin: null,\n\tmax: null,\n\tdir: 1,\n\tori: 0,\n};\n\nconst yScaleOpts = assign({}, xScaleOpts, {\n\ttime: false,\n\tori: 1,\n});\n\nconst syncs = {};\n\nfunction _sync(key, opts) {\n\tlet s = syncs[key];\n\n\tif (!s) {\n\t\ts = {\n\t\t\tkey,\n\t\t\tplots: [],\n\t\t\tsub(plot) {\n\t\t\t\ts.plots.push(plot);\n\t\t\t},\n\t\t\tunsub(plot) {\n\t\t\t\ts.plots = s.plots.filter(c => c != plot);\n\t\t\t},\n\t\t\tpub(type, self, x, y, w, h, i) {\n\t\t\t\tfor (let j = 0; j < s.plots.length; j++)\n\t\t\t\t\ts.plots[j] != self && s.plots[j].pub(type, self, x, y, w, h, i);\n\t\t\t},\n\t\t};\n\n\t\tif (key != null)\n\t\t\tsyncs[key] = s;\n\t}\n\n\treturn s;\n}\n\nconst BAND_CLIP_FILL   = 1 << 0;\nconst BAND_CLIP_STROKE = 1 << 1;\n\nfunction orient(u, seriesIdx, cb) {\n\tconst series = u.series[seriesIdx];\n\tconst scales = u.scales;\n\tconst bbox   = u.bbox;\n\tconst scaleX = u.mode == 2 ? scales[series.facets[0].scale] : scales[u.series[0].scale];\n\n\tlet dx = u._data[0],\n\t\tdy = u._data[seriesIdx],\n\t\tsx = scaleX,\n\t\tsy = u.mode == 2 ? scales[series.facets[1].scale] : scales[series.scale],\n\t\tl = bbox.left,\n\t\tt = bbox.top,\n\t\tw = bbox.width,\n\t\th = bbox.height,\n\t\tH = u.valToPosH,\n\t\tV = u.valToPosV;\n\n\treturn (sx.ori == 0\n\t\t? cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tH,\n\t\t\tV,\n\t\t\tl,\n\t\t\tt,\n\t\t\tw,\n\t\t\th,\n\t\t\tmoveToH,\n\t\t\tlineToH,\n\t\t\trectH,\n\t\t\tarcH,\n\t\t\tbezierCurveToH,\n\t\t)\n\t\t: cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tV,\n\t\t\tH,\n\t\t\tt,\n\t\t\tl,\n\t\t\th,\n\t\t\tw,\n\t\t\tmoveToV,\n\t\t\tlineToV,\n\t\t\trectV,\n\t\t\tarcV,\n\t\t\tbezierCurveToV,\n\t\t)\n\t);\n}\n\nfunction bandFillClipDirs(self, seriesIdx) {\n\tlet fillDir = 0;\n\n\t// 2 bits, -1 | 1\n\tlet clipDirs = 0;\n\n\tlet bands = ifNull(self.bands, EMPTY_ARR);\n\n\tfor (let i = 0; i < bands.length; i++) {\n\t\tlet b = bands[i];\n\n\t\t// is a \"from\" band edge\n\t\tif (b.series[0] == seriesIdx)\n\t\t\tfillDir = b.dir;\n\t\t// is a \"to\" band edge\n\t\telse if (b.series[1] == seriesIdx) {\n\t\t\tif (b.dir == 1)\n\t\t\t\tclipDirs |= 1;\n\t\t\telse\n\t\t\t\tclipDirs |= 2;\n\t\t}\n\t}\n\n\treturn [\n\t\tfillDir,\n\t\t(\n\t\t\tclipDirs == 1 ? -1 : // neg only\n\t\t\tclipDirs == 2 ?  1 : // pos only\n\t\t\tclipDirs == 3 ?  2 : // both\n\t\t\t                 0   // neither\n\t\t)\n\t];\n}\n\nfunction seriesFillTo(self, seriesIdx, dataMin, dataMax, bandFillDir) {\n\tlet scale = self.scales[self.series[seriesIdx].scale];\n\n\treturn (\n\t\tbandFillDir == -1 ? scale.min :\n\t\tbandFillDir ==  1 ? scale.max :\n\t\tscale.distr ==  3 ? (\n\t\t\tscale.dir == 1 ? scale.min :\n\t\t\tscale.max\n\t\t) : 0\n\t);\n}\n\n// creates inverted band clip path (from stroke path -> yMax || yMin)\n// clipDir is always inverse of fillDir\n// default clip dir is upwards (1), since default band fill is downwards/fillBelowTo (-1) (highIdx -> lowIdx)\nfunction clipBandLine(self, seriesIdx, idx0, idx1, strokePath, clipDir) {\n\treturn orient(self, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\tlet pxRound = series.pxRound;\n\n\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\t\tconst lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\tlet frIdx, toIdx;\n\n\t\tif (dir == 1) {\n\t\t\tfrIdx = idx0;\n\t\t\ttoIdx = idx1;\n\t\t}\n\t\telse {\n\t\t\tfrIdx = idx1;\n\t\t\ttoIdx = idx0;\n\t\t}\n\n\t\t// path start\n\t\tlet x0 = pxRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff));\n\t\tlet y0 = pxRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff));\n\t\t// path end x\n\t\tlet x1 = pxRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff));\n\t\t// upper or lower y limit\n\t\tlet yLimit = pxRound(valToPosY(clipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));\n\n\t\tlet clip = new Path2D(strokePath);\n\n\t\tlineTo(clip, x1, yLimit);\n\t\tlineTo(clip, x0, yLimit);\n\t\tlineTo(clip, x0, y0);\n\n\t\treturn clip;\n\t});\n}\n\nfunction clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {\n\tlet clip = null;\n\n\t// create clip path (invert gaps and non-gaps)\n\tif (gaps.length > 0) {\n\t\tclip = new Path2D();\n\n\t\tconst rect = ori == 0 ? rectH : rectV;\n\n\t\tlet prevGapEnd = plotLft;\n\n\t\tfor (let i = 0; i < gaps.length; i++) {\n\t\t\tlet g = gaps[i];\n\n\t\t\tif (g[1] > g[0]) {\n\t\t\t\tlet w = g[0] - prevGapEnd;\n\n\t\t\t\tw > 0 && rect(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);\n\n\t\t\t\tprevGapEnd = g[1];\n\t\t\t}\n\t\t}\n\n\t\tlet w = plotLft + plotWid - prevGapEnd;\n\n\t\tw > 0 && rect(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);\n\t}\n\n\treturn clip;\n}\n\nfunction addGap(gaps, fromX, toX) {\n\tlet prevGap = gaps[gaps.length - 1];\n\n\tif (prevGap && prevGap[0] == fromX)\t\t\t// TODO: gaps must be encoded at stroke widths?\n\t\tprevGap[1] = toX;\n\telse\n\t\tgaps.push([fromX, toX]);\n}\n\nfunction findGaps(xs, ys, idx0, idx1, dir, pixelForX, align) {\n\tlet gaps = [];\n\n\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\tlet yVal = ys[i];\n\n\t\tif (yVal === null) {\n\t\t\tlet fr = i, to = i;\n\n\t\t\tif (dir == 1) {\n\t\t\t\twhile (++i <= idx1 && ys[i] === null)\n\t\t\t\t\tto = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (--i >= idx0 && ys[i] === null)\n\t\t\t\t\tto = i;\n\t\t\t}\n\n\t\t\tlet frPx = pixelForX(xs[fr]);\n\t\t\tlet toPx = to == fr ? frPx : pixelForX(xs[to]);\n\n\t\t\t// if value adjacent to edge null is same pixel, then it's partially\n\t\t\t// filled and gap should start at next pixel\n\t\t\tlet frPx2 = align <= 0 ? pixelForX(xs[fr-dir]) : frPx;\n\t\t//\tif (frPx2 == frPx)\n\t\t//\t\tfrPx++;\n\t\t//\telse\n\t\t\t\tfrPx = frPx2;\n\n\t\t\tlet toPx2 = align >= 0 ? pixelForX(xs[to+dir]) : toPx;\n\t\t//\tif (toPx2 == toPx)\n\t\t//\t\ttoPx--;\n\t\t//\telse\n\t\t\t\ttoPx = toPx2;\n\n\t\t\tif (toPx >= frPx)\n\t\t\t\tgaps.push([frPx, toPx]); // addGap\n\t\t}\n\t}\n\n\treturn gaps;\n}\n\nfunction pxRoundGen(pxAlign) {\n\treturn pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : v => incrRound(v, pxAlign);\n}\n\nfunction rect(ori) {\n\tlet moveTo = ori == 0 ?\n\t\tmoveToH :\n\t\tmoveToV;\n\n\tlet arcTo = ori == 0 ?\n\t\t(p, x1, y1, x2, y2, r) => { p.arcTo(x1, y1, x2, y2, r); } :\n\t\t(p, y1, x1, y2, x2, r) => { p.arcTo(x1, y1, x2, y2, r); };\n\n\tlet rect = ori == 0 ?\n\t\t(p, x, y, w, h) => { p.rect(x, y, w, h); } :\n\t\t(p, y, x, h, w) => { p.rect(x, y, w, h); };\n\n\treturn (p, x, y, w, h, r = 0) => {\n\t\tif (r == 0)\n\t\t\trect(p, x, y, w, h);\n\t\telse {\n\t\t\tr = min(r, w / 2, h / 2);\n\n\t\t\t// adapted from https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-using-html-canvas/7838871#7838871\n\t\t\tmoveTo(p, x + r, y);\n\t\t\tarcTo(p, x + w, y, x + w, y + h, r);\n\t\t\tarcTo(p, x + w, y + h, x, y + h, r);\n\t\t\tarcTo(p, x, y + h, x, y, r);\n\t\t\tarcTo(p, x, y, x + w, y, r);\n\t\t\tp.closePath();\n\t\t}\n\t};\n}\n\n// orientation-inverting canvas functions\nconst moveToH = (p, x, y) => { p.moveTo(x, y); };\nconst moveToV = (p, y, x) => { p.moveTo(x, y); };\nconst lineToH = (p, x, y) => { p.lineTo(x, y); };\nconst lineToV = (p, y, x) => { p.lineTo(x, y); };\nconst rectH = rect(0);\nconst rectV = rect(1);\nconst arcH = (p, x, y, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };\nconst arcV = (p, y, x, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };\nconst bezierCurveToH = (p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };\nconst bezierCurveToV = (p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };\n\n// TODO: drawWrap(seriesIdx, drawPoints) (save, restore, translate, clip)\nfunction points(opts) {\n\treturn (u, seriesIdx, idx0, idx1, filtIdxs) => {\n\t//\tlog(\"drawPoints()\", arguments);\n\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet { pxRound, points } = series;\n\n\t\t\tlet moveTo, arc;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tmoveTo = moveToH;\n\t\t\t\tarc = arcH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveTo = moveToV;\n\t\t\t\tarc = arcV;\n\t\t\t}\n\n\t\t\tconst width = roundDec(points.width * pxRatio, 3);\n\n\t\t\tlet rad = (points.size - points.width) / 2 * pxRatio;\n\t\t\tlet dia = roundDec(rad * 2, 3);\n\n\t\t\tlet fill = new Path2D();\n\t\t\tlet clip = new Path2D();\n\n\t\t\tlet { left: lft, top: top, width: wid, height: hgt } = u.bbox;\n\n\t\t\trectH(clip,\n\t\t\t\tlft - dia,\n\t\t\t\ttop - dia,\n\t\t\t\twid + dia * 2,\n\t\t\t\thgt + dia * 2,\n\t\t\t);\n\n\t\t\tconst drawPoint = pi => {\n\t\t\t\tif (dataY[pi] != null) {\n\t\t\t\t\tlet x = pxRound(valToPosX(dataX[pi], scaleX, xDim, xOff));\n\t\t\t\t\tlet y = pxRound(valToPosY(dataY[pi], scaleY, yDim, yOff));\n\n\t\t\t\t\tmoveTo(fill, x + rad, y);\n\t\t\t\t\tarc(fill, x, y, rad, 0, PI * 2);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (filtIdxs)\n\t\t\t\tfiltIdxs.forEach(drawPoint);\n\t\t\telse {\n\t\t\t\tfor (let pi = idx0; pi <= idx1; pi++)\n\t\t\t\t\tdrawPoint(pi);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstroke: width > 0 ? fill : null,\n\t\t\t\tfill,\n\t\t\t\tclip,\n\t\t\t\tflags: BAND_CLIP_FILL | BAND_CLIP_STROKE,\n\t\t\t};\n\t\t});\n\t};\n}\n\nfunction _drawAcc(lineTo) {\n\treturn (stroke, accX, minY, maxY, inY, outY) => {\n\t\tif (minY != maxY) {\n\t\t\tif (inY != minY && outY != minY)\n\t\t\t\tlineTo(stroke, accX, minY);\n\t\t\tif (inY != maxY && outY != maxY)\n\t\t\t\tlineTo(stroke, accX, maxY);\n\n\t\t\tlineTo(stroke, accX, outY);\n\t\t}\n\t};\n}\n\nconst drawAccH = _drawAcc(lineToH);\nconst drawAccV = _drawAcc(lineToV);\n\nfunction linear(opts) {\n\tconst alignGaps = ifNull(opts?.alignGaps, 0);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet lineTo, drawAcc;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tdrawAcc = drawAccH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tdrawAcc = drawAccV;\n\t\t\t}\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tlet minY = inf,\n\t\t\t\tmaxY = -inf,\n\t\t\t\tinY, outY, drawnAtX;\n\n\t\t\tlet accX = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\n\t\t\t// data edges\n\t\t\tlet lftIdx = nonNullIdx(dataY, idx0, idx1,  1 * dir);\n\t\t\tlet rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);\n\t\t\tlet lftX   =  pixelForX(dataX[lftIdx]);\n\t\t\tlet rgtX   =  pixelForX(dataX[rgtIdx]);\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet x = pixelForX(dataX[i]);\n\n\t\t\t\tif (x == accX) {\n\t\t\t\t\tif (dataY[i] != null) {\n\t\t\t\t\t\toutY = pixelForY(dataY[i]);\n\n\t\t\t\t\t\tif (minY == inf) {\n\t\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\t\tinY = outY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminY = min(outY, minY);\n\t\t\t\t\t\tmaxY = max(outY, maxY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (minY != inf) {\n\t\t\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\t\t\t\t\t\tdrawnAtX = accX;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dataY[i] != null) {\n\t\t\t\t\t\toutY = pixelForY(dataY[i]);\n\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\tminY = maxY = inY = outY;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tminY = inf;\n\t\t\t\t\t\tmaxY = -inf;\n\t\t\t\t\t}\n\n\t\t\t\t\taccX = x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minY != inf && minY != maxY && drawnAtX != accX)\n\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillToVal = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillToVal);\n\n\t\t\t\tlineTo(fill, rgtX, fillToY);\n\t\t\t\tlineTo(fill, lftX, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\tgaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction stepped(opts) {\n\tconst align = ifNull(opts.align, 1);\n\t// whether to draw ascenders/descenders at null/gap bondaries\n\tconst ascDesc = ifNull(opts.ascDesc, false);\n\n\tconst alignGaps = ifNull(opts.alignGaps, 0);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet prevYPos  = pixelForY(dataY[dir == 1 ? idx0 : idx1]);\n\t\t\tlet firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlineTo(stroke, firstXPos, prevYPos);\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet yVal1 = dataY[i];\n\n\t\t\t\tif (yVal1 == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet x1 = pixelForX(dataX[i]);\n\t\t\t\tlet y1 = pixelForY(yVal1);\n\n\t\t\t\tif (align == 1)\n\t\t\t\t\tlineTo(stroke, x1, prevYPos);\n\t\t\t\telse\n\t\t\t\t\tlineTo(stroke, prevXPos, y1);\n\n\t\t\t\tlineTo(stroke, x1, y1);\n\n\t\t\t\tprevYPos = y1;\n\t\t\t\tprevXPos = x1;\n\t\t\t}\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillTo);\n\n\t\t\t\tlineTo(fill, prevXPos, fillToY);\n\t\t\t\tlineTo(fill, firstXPos, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\tgaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t// expand/contract clips for ascenders/descenders\n\t\t\t\tlet halfStroke = (series.width * pxRatio) / 2;\n\t\t\t\tlet startsOffset = (ascDesc || align ==  1) ?  halfStroke : -halfStroke;\n\t\t\t\tlet endsOffset   = (ascDesc || align == -1) ? -halfStroke :  halfStroke;\n\n\t\t\t\tgaps.forEach(g => {\n\t\t\t\t\tg[0] += startsOffset;\n\t\t\t\t\tg[1] += endsOffset;\n\t\t\t\t});\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction bars(opts) {\n\topts = opts || EMPTY_OBJ;\n\tconst size = ifNull(opts.size, [0.6, inf, 1]);\n\tconst align = opts.align || 0;\n\tconst extraGap = (opts.gap || 0) * pxRatio;\n\n\tconst radius = ifNull(opts.radius, 0);\n\n\tconst gapFactor = 1 - size[0];\n\tconst maxWidth  = ifNull(size[1], inf) * pxRatio;\n\tconst minWidth  = ifNull(size[2], 1) * pxRatio;\n\n\tconst disp = ifNull(opts.disp, EMPTY_OBJ);\n\tconst _each = ifNull(opts.each, _ => {});\n\n\tconst { fill: dispFills, stroke: dispStrokes } = disp;\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tconst _dirX = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\t\t\tconst _dirY = scaleY.dir * (scaleY.ori == 1 ? 1 : -1);\n\n\t\t\tlet rect = scaleX.ori == 0 ? rectH : rectV;\n\n\t\t\tlet each = scaleX.ori == 0 ? _each : (u, seriesIdx, i, top, lft, hgt, wid) => {\n\t\t\t\t_each(u, seriesIdx, i, lft, top, wid, hgt);\n\t\t\t};\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t//\tlet fillToY = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\tlet fillToY = scaleY.distr == 3 ? (bandFillDir == 1 ? scaleY.max : scaleY.min) : 0;\n\n\t\t\tlet y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);\n\n\t\t\t// barWid is to center of stroke\n\t\t\tlet xShift, barWid;\n\n\t\t\tlet strokeWidth = pxRound(series.width * pxRatio);\n\n\t\t\tlet multiPath = false;\n\n\t\t\tlet fillColors = null;\n\t\t\tlet fillPaths = null;\n\t\t\tlet strokeColors = null;\n\t\t\tlet strokePaths = null;\n\n\t\t\tif (dispFills != null && (strokeWidth == 0 || dispStrokes != null)) {\n\t\t\t\tmultiPath = true;\n\n\t\t\t\tfillColors = dispFills.values(u, seriesIdx, idx0, idx1);\n\t\t\t\tfillPaths = new Map();\n\t\t\t\t(new Set(fillColors)).forEach(color => {\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tfillPaths.set(color, new Path2D());\n\t\t\t\t});\n\n\t\t\t\tif (strokeWidth > 0) {\n\t\t\t\t\tstrokeColors = dispStrokes.values(u, seriesIdx, idx0, idx1);\n\t\t\t\t\tstrokePaths = new Map();\n\t\t\t\t\t(new Set(strokeColors)).forEach(color => {\n\t\t\t\t\t\tif (color != null)\n\t\t\t\t\t\t\tstrokePaths.set(color, new Path2D());\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet { x0, size } = disp;\n\n\t\t\tif (x0 != null && size != null) {\n\t\t\t\tdataX = x0.values(u, seriesIdx, idx0, idx1);\n\n\t\t\t\tif (x0.unit == 2)\n\t\t\t\t\tdataX = dataX.map(pct => u.posToVal(xOff + pct * xDim, scaleX.key, true));\n\n\t\t\t\t// assumes uniform sizes, for now\n\t\t\t\tlet sizes = size.values(u, seriesIdx, idx0, idx1);\n\n\t\t\t\tif (size.unit == 2)\n\t\t\t\t\tbarWid = sizes[0] * xDim;\n\t\t\t\telse\n\t\t\t\t\tbarWid = valToPosX(sizes[0], scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff); // assumes linear scale (delta from 0)\n\n\t\t\t\tbarWid = pxRound(barWid - strokeWidth);\n\n\t\t\t\txShift = (_dirX == 1 ? -strokeWidth / 2 : barWid + strokeWidth / 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet colWid = xDim;\n\n\t\t\t\tif (dataX.length > 1) {\n\t\t\t\t\t// prior index with non-undefined y data\n\t\t\t\t\tlet prevIdx = null;\n\n\t\t\t\t\t// scan full dataset for smallest adjacent delta\n\t\t\t\t\t// will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end\n\t\t\t\t\tfor (let i = 0, minDelta = Infinity; i < dataX.length; i++) {\n\t\t\t\t\t\tif (dataY[i] !== undefined) {\n\t\t\t\t\t\t\tif (prevIdx != null) {\n\t\t\t\t\t\t\t\tlet delta = abs(dataX[i] - dataX[prevIdx]);\n\n\t\t\t\t\t\t\t\tif (delta < minDelta) {\n\t\t\t\t\t\t\t\t\tminDelta = delta;\n\t\t\t\t\t\t\t\t\tcolWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[prevIdx], scaleX, xDim, xOff));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprevIdx = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet gapWid = colWid * gapFactor;\n\n\t\t\t\tbarWid = pxRound(min(maxWidth, max(minWidth, colWid - gapWid)) - strokeWidth - extraGap);\n\n\t\t\t\txShift = (align == 0 ? barWid / 2 : align == _dirX ? 0 : barWid) - align * _dirX * extraGap / 2;\n\t\t\t}\n\n\t\t\tconst _paths = {stroke: null, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE};  // disp, geom\n\n\t\t\tlet yLimit;\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = new Path2D();\n\t\t\t\tyLimit = pxRound(valToPosY(bandClipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));\n\t\t\t}\n\n\t\t\tconst stroke = multiPath ? null : new Path2D();\n\t\t\tconst band = _paths.band;\n\n\t\t\tlet { y0, y1 } = disp;\n\n\t\t\tlet dataY0 = null;\n\n\t\t\tif (y0 != null && y1 != null) {\n\t\t\t\tdataY = y1.values(u, seriesIdx, idx0, idx1);\n\t\t\t\tdataY0 = y0.values(u, seriesIdx, idx0, idx1);\n\t\t\t}\n\n\t\t\tfor (let i = _dirX == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dirX) {\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\t// we can skip both, drawing and band clipping for alignment artifacts\n\t\t\t\tif (yVal === undefined)\n\t\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t\t// interpolate upwards band clips\n\t\t\t\tif (yVal == null) {\n\t\t\t\t//\tif (hasBands)\n\t\t\t\t//\t\tyVal = costlyLerp(i, idx0, idx1, _dirX, dataY);\n\t\t\t\t//\telse\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t*/\n\n\t\t\t\tlet xVal = scaleX.distr != 2 || disp != null ? dataX[i] : i;\n\n\t\t\t\t// TODO: all xPos can be pre-computed once for all series in aligned set\n\t\t\t\tlet xPos = valToPosX(xVal, scaleX, xDim, xOff);\n\t\t\t\tlet yPos = valToPosY(ifNull(yVal, fillToY), scaleY, yDim, yOff);\n\n\t\t\t\tif (dataY0 != null && yVal != null)\n\t\t\t\t\ty0Pos = valToPosY(dataY0[i], scaleY, yDim, yOff);\n\n\t\t\t\tlet lft = pxRound(xPos - xShift);\n\t\t\t\tlet btm = pxRound(max(yPos, y0Pos));\n\t\t\t\tlet top = pxRound(min(yPos, y0Pos));\n\t\t\t\t// this includes the stroke\n\t\t\t\tlet barHgt = btm - top;\n\n\t\t\t\tlet r = radius * barWid;\n\n\t\t\t\tif (yVal != null) {  // && yVal != fillToY (0 height bar)\n\t\t\t\t\tif (multiPath) {\n\t\t\t\t\t\tif (strokeWidth > 0 && strokeColors[i] != null)\n\t\t\t\t\t\t\trect(strokePaths.get(strokeColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);\n\n\t\t\t\t\t\tif (fillColors[i] != null)\n\t\t\t\t\t\t\trect(fillPaths.get(fillColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trect(stroke, lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), r);\n\n\t\t\t\t\teach(u, seriesIdx, i,\n\t\t\t\t\t\tlft    - strokeWidth / 2,\n\t\t\t\t\t\ttop,\n\t\t\t\t\t\tbarWid + strokeWidth,\n\t\t\t\t\t\tbarHgt,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (bandClipDir != 0) {\n\t\t\t\t\tif (_dirY * bandClipDir == 1) {\n\t\t\t\t\t\tbtm = top;\n\t\t\t\t\t\ttop = yLimit;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttop = btm;\n\t\t\t\t\t\tbtm = yLimit;\n\t\t\t\t\t}\n\n\t\t\t\t\tbarHgt = btm - top;\n\n\t\t\t\t\trect(band, lft - strokeWidth / 2, top, barWid + strokeWidth, max(0, barHgt), 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strokeWidth > 0)\n\t\t\t\t_paths.stroke = multiPath ? strokePaths : stroke;\n\n\t\t\t_paths.fill = multiPath ? fillPaths : stroke;\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction splineInterp(interp, opts) {\n\tconst alignGaps = ifNull(opts?.alignGaps, 0);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet moveTo, bezierCurveTo, lineTo;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tmoveTo = moveToH;\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tbezierCurveTo = bezierCurveToH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveTo = moveToV;\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tbezierCurveTo = bezierCurveToV;\n\t\t\t}\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlet xCoords = [];\n\t\t\tlet yCoords = [];\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\tif (yVal != null) {\n\t\t\t\t\tlet xVal = dataX[i];\n\t\t\t\t\tlet xPos = pixelForX(xVal);\n\n\t\t\t\t\txCoords.push(prevXPos = xPos);\n\t\t\t\t\tyCoords.push(pixelForY(dataY[i]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _paths = {stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillTo);\n\n\t\t\t\tlineTo(fill, prevXPos, fillToY);\n\t\t\t\tlineTo(fill, firstXPos, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\tgaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\n\t\t\t//  if FEAT_PATHS: false in rollup.config.js\n\t\t\t//\tu.ctx.save();\n\t\t\t//\tu.ctx.beginPath();\n\t\t\t//\tu.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n\t\t\t//\tu.ctx.clip();\n\t\t\t//\tu.ctx.strokeStyle = u.series[sidx].stroke;\n\t\t\t//\tu.ctx.stroke(stroke);\n\t\t\t//\tu.ctx.fillStyle = u.series[sidx].fill;\n\t\t\t//\tu.ctx.fill(fill);\n\t\t\t//\tu.ctx.restore();\n\t\t\t//\treturn null;\n\t\t});\n\t};\n}\n\nfunction monotoneCubic(opts) {\n\treturn splineInterp(_monotoneCubic, opts);\n}\n\n// Monotone Cubic Spline interpolation, adapted from the Chartist.js implementation:\n// https://github.com/gionkunz/chartist-js/blob/e7e78201bffe9609915e5e53cfafa29a5d6c49f9/src/scripts/interpolation.js#L240-L369\nfunction _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {\n\tconst n = xs.length;\n\n\tif (n < 2)\n\t\treturn null;\n\n\tconst path = new Path2D();\n\n\tmoveTo(path, xs[0], ys[0]);\n\n\tif (n == 2)\n\t\tlineTo(path, xs[1], ys[1]);\n\telse {\n\t\tlet ms  = Array(n),\n\t\t\tds  = Array(n - 1),\n\t\t\tdys = Array(n - 1),\n\t\t\tdxs = Array(n - 1);\n\n\t\t// calc deltas and derivative\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tdys[i] = ys[i + 1] - ys[i];\n\t\t\tdxs[i] = xs[i + 1] - xs[i];\n\t\t\tds[i]  = dys[i] / dxs[i];\n\t\t}\n\n\t\t// determine desired slope (m) at each point using Fritsch-Carlson method\n\t\t// http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\n\t\tms[0] = ds[0];\n\n\t\tfor (let i = 1; i < n - 1; i++) {\n\t\t\tif (ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0))\n\t\t\t\tms[i] = 0;\n\t\t\telse {\n\t\t\t\tms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\n\t\t\t\t\t(2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\n\t\t\t\t\t(dxs[i] + 2 * dxs[i - 1]) / ds[i]\n\t\t\t\t);\n\n\t\t\t\tif (!isFinite(ms[i]))\n\t\t\t\t\tms[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tms[n - 1] = ds[n - 2];\n\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tbezierCurveTo(\n\t\t\t\tpath,\n\t\t\t\txs[i] + dxs[i] / 3,\n\t\t\t\tys[i] + ms[i] * dxs[i] / 3,\n\t\t\t\txs[i + 1] - dxs[i] / 3,\n\t\t\t\tys[i + 1] - ms[i + 1] * dxs[i] / 3,\n\t\t\t\txs[i + 1],\n\t\t\t\tys[i + 1],\n\t\t\t);\n\t\t}\n\t}\n\n\treturn path;\n}\n\nconst cursorPlots = new Set();\n\nfunction invalidateRects() {\n\tcursorPlots.forEach(u => {\n\t\tu.syncRect(true);\n\t});\n}\n\nif (domEnv) {\n\ton(resize, win, invalidateRects);\n\ton(scroll, win, invalidateRects, true);\n\ton(dppxchange, win, () => { uPlot.pxRatio = pxRatio; });\n}\n\nconst linearPath = linear() ;\nconst pointsPath = points() ;\n\nfunction setDefaults(d, xo, yo, initY) {\n\tlet d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));\n\treturn d2.map((o, i) => setDefault(o, i, xo, yo));\n}\n\nfunction setDefaults2(d, xyo) {\n\treturn d.map((o, i) => i == 0 ? null : assign({}, xyo, o));  // todo: assign() will not merge facet arrays\n}\n\nfunction setDefault(o, i, xo, yo) {\n\treturn assign({}, (i == 0 ? xo : yo), o);\n}\n\nfunction snapNumX(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : [dataMin, dataMax];\n}\n\nconst snapTimeX = snapNumX;\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction snapNumY(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, rangePad, true);\n}\n\nfunction snapLogY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapLogX = snapLogY;\n\nfunction snapAsinhY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapAsinhX = snapAsinhY;\n\n// dim is logical (getClientBoundingRect) pixels, not canvas pixels\nfunction findIncr(minVal, maxVal, incrs, dim, minSpace) {\n\tlet intDigits = max(numIntDigits(minVal), numIntDigits(maxVal));\n\n\tlet delta = maxVal - minVal;\n\n\tlet incrIdx = closestIdx((minSpace / dim) * delta, incrs);\n\n\tdo {\n\t\tlet foundIncr = incrs[incrIdx];\n\t\tlet foundSpace = dim * foundIncr / delta;\n\n\t\tif (foundSpace >= minSpace && intDigits + (foundIncr < 5 ? fixedDec.get(foundIncr) : 0) <= 17)\n\t\t\treturn [foundIncr, foundSpace];\n\t} while (++incrIdx < incrs.length);\n\n\treturn [0, 0];\n}\n\nfunction pxRatioFont(font) {\n\tlet fontSize, fontSizeCss;\n\tfont = font.replace(/(\\d+)px/, (m, p1) => (fontSize = round((fontSizeCss = +p1) * pxRatio)) + 'px');\n\treturn [font, fontSize, fontSizeCss];\n}\n\nfunction syncFontSize(axis) {\n\tif (axis.show) {\n\t\t[axis.font, axis.labelFont].forEach(f => {\n\t\t\tlet size = roundDec(f[2] * pxRatio, 1);\n\t\t\tf[0] = f[0].replace(/[0-9.]+px/, size + 'px');\n\t\t\tf[1] = size;\n\t\t});\n\t}\n}\n\nfunction uPlot(opts, data, then) {\n\tconst self = {\n\t\tmode: ifNull(opts.mode, 1),\n\t};\n\n\tconst mode = self.mode;\n\n\t// TODO: cache denoms & mins scale.cache = {r, min, }\n\tfunction getValPct(val, scale) {\n\t\tlet _val = (\n\t\t\tscale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self, val, scale.min, scale.max, scale.key)) :\n\t\t\tscale.distr == 4 ? asinh(val, scale.asinh) :\n\t\t\tval\n\t\t);\n\n\t\treturn (_val - scale._min) / (scale._max - scale._min);\n\t}\n\n\tfunction getHPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? (1 - pct) : pct);\n\t}\n\n\tfunction getVPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? pct : (1 - pct));\n\t}\n\n\tfunction getPos(val, scale, dim, off) {\n\t\treturn scale.ori == 0 ? getHPos(val, scale, dim, off) : getVPos(val, scale, dim, off);\n\t}\n\n\tself.valToPosH = getHPos;\n\tself.valToPosV = getVPos;\n\n\tlet ready = false;\n\tself.status = 0;\n\n\tconst root = self.root = placeDiv(UPLOT);\n\n\tif (opts.id != null)\n\t\troot.id = opts.id;\n\n\taddClass(root, opts.class);\n\n\tif (opts.title) {\n\t\tlet title = placeDiv(TITLE, root);\n\t\ttitle.textContent = opts.title;\n\t}\n\n\tconst can = placeTag(\"canvas\");\n\tconst ctx = self.ctx = can.getContext(\"2d\");\n\n\tconst wrap = placeDiv(WRAP, root);\n\tconst under = self.under = placeDiv(UNDER, wrap);\n\twrap.appendChild(can);\n\tconst over = self.over = placeDiv(OVER, wrap);\n\n\topts = copy(opts);\n\n\tconst pxAlign = +ifNull(opts.pxAlign, 1);\n\n\tconst pxRound = pxRoundGen(pxAlign);\n\n\t(opts.plugins || []).forEach(p => {\n\t\tif (p.opts)\n\t\t\topts = p.opts(self, opts) || opts;\n\t});\n\n\tconst ms = opts.ms || 1e-3;\n\n\tconst series  = self.series = mode == 1 ?\n\t\tsetDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false) :\n\t\tsetDefaults2(opts.series || [null], xySeriesOpts);\n\tconst axes    = self.axes   = setDefaults(opts.axes   || [], xAxisOpts,   yAxisOpts,    true);\n\tconst scales  = self.scales = {};\n\tconst bands   = self.bands  = opts.bands || [];\n\n\tbands.forEach(b => {\n\t\tb.fill = fnOrSelf(b.fill || null);\n\t\tb.dir = ifNull(b.dir, -1);\n\t});\n\n\tconst xScaleKey = mode == 2 ? series[1].facets[0].scale : series[0].scale;\n\n\tconst drawOrderMap = {\n\t\taxes: drawAxesGrid,\n\t\tseries: drawSeries,\n\t};\n\n\tconst drawOrder = (opts.drawOrder || [\"axes\", \"series\"]).map(key => drawOrderMap[key]);\n\n\tfunction initScale(scaleKey) {\n\t\tlet sc = scales[scaleKey];\n\n\t\tif (sc == null) {\n\t\t\tlet scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;\n\n\t\t\tif (scaleOpts.from != null) {\n\t\t\t\t// ensure parent is initialized\n\t\t\t\tinitScale(scaleOpts.from);\n\t\t\t\t// dependent scales inherit\n\t\t\t\tscales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts, {key: scaleKey});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsc = scales[scaleKey] = assign({}, (scaleKey == xScaleKey ? xScaleOpts : yScaleOpts), scaleOpts);\n\n\t\t\t\tsc.key = scaleKey;\n\n\t\t\t\tlet isTime = sc.time;\n\n\t\t\t\tlet rn = sc.range;\n\n\t\t\t\tlet rangeIsArr = isArr(rn);\n\n\t\t\t\tif (scaleKey != xScaleKey || (mode == 2 && !isTime)) {\n\t\t\t\t\t// if range array has null limits, it should be auto\n\t\t\t\t\tif (rangeIsArr && (rn[0] == null || rn[1] == null)) {\n\t\t\t\t\t\trn = {\n\t\t\t\t\t\t\tmin: rn[0] == null ? autoRangePart : {\n\t\t\t\t\t\t\t\tmode: 1,\n\t\t\t\t\t\t\t\thard: rn[0],\n\t\t\t\t\t\t\t\tsoft: rn[0],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmax: rn[1] == null ? autoRangePart : {\n\t\t\t\t\t\t\t\tmode: 1,\n\t\t\t\t\t\t\t\thard: rn[1],\n\t\t\t\t\t\t\t\tsoft: rn[1],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t\trangeIsArr = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!rangeIsArr && isObj(rn)) {\n\t\t\t\t\t\tlet cfg = rn;\n\t\t\t\t\t\t// this is similar to snapNumY\n\t\t\t\t\t\trn = (self, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ?\n\t\t\t\t\t(sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX) :\n\t\t\t\t\t(sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY)\n\t\t\t\t));\n\n\t\t\t\tsc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);\n\n\t\t\t\tsc.clamp = fnOrSelf(sc.clamp || clampScale);\n\n\t\t\t\t// caches for expensive ops like asinh() & log()\n\t\t\t\tsc._min = sc._max = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tinitScale(\"x\");\n\tinitScale(\"y\");\n\n\t// TODO: init scales from facets in mode: 2\n\tif (mode == 1) {\n\t\tseries.forEach(s => {\n\t\t\tinitScale(s.scale);\n\t\t});\n\t}\n\n\taxes.forEach(a => {\n\t\tinitScale(a.scale);\n\t});\n\n\tfor (let k in opts.scales)\n\t\tinitScale(k);\n\n\tconst scaleX = scales[xScaleKey];\n\n\tconst xScaleDistr = scaleX.distr;\n\n\tlet valToPosX, valToPosY;\n\n\tif (scaleX.ori == 0) {\n\t\taddClass(root, ORI_HZ);\n\t\tvalToPosX = getHPos;\n\t\tvalToPosY = getVPos;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotWid;\n\t\t\txOffCan = plotLft;\n\t\t\tyDimCan = plotHgt;\n\t\t\tyOffCan = plotTop;\n\n\t\t\txDimCss = plotWidCss;\n\t\t\txOffCss = plotLftCss;\n\t\t\tyDimCss = plotHgtCss;\n\t\t\tyOffCss = plotTopCss;\n\t\t};\n\t\t*/\n\t}\n\telse {\n\t\taddClass(root, ORI_VT);\n\t\tvalToPosX = getVPos;\n\t\tvalToPosY = getHPos;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotHgt;\n\t\t\txOffCan = plotTop;\n\t\t\tyDimCan = plotWid;\n\t\t\tyOffCan = plotLft;\n\n\t\t\txDimCss = plotHgtCss;\n\t\t\txOffCss = plotTopCss;\n\t\t\tyDimCss = plotWidCss;\n\t\t\tyOffCss = plotLftCss;\n\t\t};\n\t\t*/\n\t}\n\n\tconst pendScales = {};\n\n\t// explicitly-set initial scales\n\tfor (let k in scales) {\n\t\tlet sc = scales[k];\n\n\t\tif (sc.min != null || sc.max != null) {\n\t\t\tpendScales[k] = {min: sc.min, max: sc.max};\n\t\t\tsc.min = sc.max = null;\n\t\t}\n\t}\n\n//\tself.tz = opts.tz || Intl.DateTimeFormat().resolvedOptions().timeZone;\n\tconst _tzDate  = (opts.tzDate || (ts => new Date(round(ts / ms))));\n\tconst _fmtDate = (opts.fmtDate || fmtDate);\n\n\tconst _timeAxisSplits = (ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate));\n\tconst _timeAxisVals   = timeAxisVals(_tzDate, timeAxisStamps((ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS), _fmtDate));\n\tconst _timeSeriesVal  = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));\n\n\tconst activeIdxs = [];\n\n\tconst legend     = (self.legend = assign({}, legendOpts, opts.legend));\n\tconst showLegend = legend.show;\n\tconst markers    = legend.markers;\n\n\t{\n\t\tlegend.idxs = activeIdxs;\n\n\t\tmarkers.width  = fnOrSelf(markers.width);\n\t\tmarkers.dash   = fnOrSelf(markers.dash);\n\t\tmarkers.stroke = fnOrSelf(markers.stroke);\n\t\tmarkers.fill   = fnOrSelf(markers.fill);\n\t}\n\n\tlet legendEl;\n\tlet legendRows = [];\n\tlet legendCells = [];\n\tlet legendCols;\n\tlet multiValLegend = false;\n\tlet NULL_LEGEND_VALUES = {};\n\n\tif (legend.live) {\n\t\tconst getMultiVals = series[1] ? series[1].values : null;\n\t\tmultiValLegend = getMultiVals != null;\n\t\tlegendCols = multiValLegend ? getMultiVals(self, 1, 0) : {_: 0};\n\n\t\tfor (let k in legendCols)\n\t\t\tNULL_LEGEND_VALUES[k] = \"--\";\n\t}\n\n\tif (showLegend) {\n\t\tlegendEl = placeTag(\"table\", LEGEND, root);\n\n\t\tif (multiValLegend) {\n\t\t\tlet head = placeTag(\"tr\", LEGEND_THEAD, legendEl);\n\t\t\tplaceTag(\"th\", null, head);\n\n\t\t\tfor (var key in legendCols)\n\t\t\t\tplaceTag(\"th\", LEGEND_LABEL, head).textContent = key;\n\t\t}\n\t\telse {\n\t\t\taddClass(legendEl, LEGEND_INLINE);\n\t\t\tlegend.live && addClass(legendEl, LEGEND_LIVE);\n\t\t}\n\t}\n\n\tconst son  = {show: true};\n\tconst soff = {show: false};\n\n\tfunction initLegendRow(s, i) {\n\t\tif (i == 0 && (multiValLegend || !legend.live || mode == 2))\n\t\t\treturn nullNullTuple;\n\n\t\tlet cells = [];\n\n\t\tlet row = placeTag(\"tr\", LEGEND_SERIES, legendEl, legendEl.childNodes[i]);\n\n\t\taddClass(row, s.class);\n\n\t\tif (!s.show)\n\t\t\taddClass(row, OFF);\n\n\t\tlet label = placeTag(\"th\", null, row);\n\n\t\tif (markers.show) {\n\t\t\tlet indic = placeDiv(LEGEND_MARKER, label);\n\n\t\t\tif (i > 0) {\n\t\t\t\tlet width  = markers.width(self, i);\n\n\t\t\t\tif (width)\n\t\t\t\t\tindic.style.border = width + \"px \" + markers.dash(self, i) + \" \" + markers.stroke(self, i);\n\n\t\t\t\tindic.style.background = markers.fill(self, i);\n\t\t\t}\n\t\t}\n\n\t\tlet text = placeDiv(LEGEND_LABEL, label);\n\t\ttext.textContent = s.label;\n\n\t\tif (i > 0) {\n\t\t\tif (!markers.show)\n\t\t\t\ttext.style.color = s.width > 0 ? markers.stroke(self, i) : markers.fill(self, i);\n\n\t\t\tonMouse(\"click\", label, e => {\n\t\t\t\tif (cursor._lock)\n\t\t\t\t\treturn;\n\n\t\t\t\tlet seriesIdx = series.indexOf(s);\n\n\t\t\t\tif ((e.ctrlKey || e.metaKey) != legend.isolate) {\n\t\t\t\t\t// if any other series is shown, isolate this one. else show all\n\t\t\t\t\tlet isolate = series.some((s, i) => i > 0 && i != seriesIdx && s.show);\n\n\t\t\t\t\tseries.forEach((s, i) => {\n\t\t\t\t\t\ti > 0 && setSeries(i, isolate ? (i == seriesIdx ? son : soff) : son, true, syncOpts.setSeries);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsetSeries(seriesIdx, {show: !s.show}, true, syncOpts.setSeries);\n\t\t\t});\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tonMouse(mouseenter, label, e => {\n\t\t\t\t\tif (cursor._lock)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tsetSeries(series.indexOf(s), FOCUS_TRUE, true, syncOpts.setSeries);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in legendCols) {\n\t\t\tlet v = placeTag(\"td\", LEGEND_VALUE, row);\n\t\t\tv.textContent = \"--\";\n\t\t\tcells.push(v);\n\t\t}\n\n\t\treturn [row, cells];\n\t}\n\n\tconst mouseListeners = new Map();\n\n\tfunction onMouse(ev, targ, fn) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\t\tconst listener = cursor.bind[ev](self, targ, fn);\n\n\t\tif (listener) {\n\t\t\ton(ev, targ, targListeners[ev] = listener);\n\t\t\tmouseListeners.set(targ, targListeners);\n\t\t}\n\t}\n\n\tfunction offMouse(ev, targ, fn) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\n\t\tfor (let k in targListeners) {\n\t\t\tif (ev == null || k == ev) {\n\t\t\t\toff(k, targ, targListeners[k]);\n\t\t\t\tdelete targListeners[k];\n\t\t\t}\n\t\t}\n\n\t\tif (ev == null)\n\t\t\tmouseListeners.delete(targ);\n\t}\n\n\tlet fullWidCss = 0;\n\tlet fullHgtCss = 0;\n\n\tlet plotWidCss = 0;\n\tlet plotHgtCss = 0;\n\n\t// plot margins to account for axes\n\tlet plotLftCss = 0;\n\tlet plotTopCss = 0;\n\n\tlet plotLft = 0;\n\tlet plotTop = 0;\n\tlet plotWid = 0;\n\tlet plotHgt = 0;\n\n\tself.bbox = {};\n\n\tlet shouldSetScales = false;\n\tlet shouldSetSize = false;\n\tlet shouldConvergeSize = false;\n\tlet shouldSetCursor = false;\n\tlet shouldSetLegend = false;\n\n\tfunction _setSize(width, height, force) {\n\t\tif (force || (width != self.width || height != self.height))\n\t\t\tcalcSize(width, height);\n\n\t\tresetYSeries(false);\n\n\t\tshouldConvergeSize = true;\n\t\tshouldSetSize = true;\n\t\tshouldSetCursor = shouldSetLegend = cursor.left >= 0;\n\t\tcommit();\n\t}\n\n\tfunction calcSize(width, height) {\n\t//\tlog(\"calcSize()\", arguments);\n\n\t\tself.width  = fullWidCss = plotWidCss = width;\n\t\tself.height = fullHgtCss = plotHgtCss = height;\n\t\tplotLftCss  = plotTopCss = 0;\n\n\t\tcalcPlotRect();\n\t\tcalcAxesRects();\n\n\t\tlet bb = self.bbox;\n\n\t\tplotLft = bb.left   = incrRound(plotLftCss * pxRatio, 0.5);\n\t\tplotTop = bb.top    = incrRound(plotTopCss * pxRatio, 0.5);\n\t\tplotWid = bb.width  = incrRound(plotWidCss * pxRatio, 0.5);\n\t\tplotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);\n\n\t//\tupdOriDims();\n\t}\n\n\t// ensures size calc convergence\n\tconst CYCLE_LIMIT = 3;\n\n\tfunction convergeSize() {\n\t\tlet converged = false;\n\n\t\tlet cycleNum = 0;\n\n\t\twhile (!converged) {\n\t\t\tcycleNum++;\n\n\t\t\tlet axesConverged = axesCalc(cycleNum);\n\t\t\tlet paddingConverged = paddingCalc(cycleNum);\n\n\t\t\tconverged = cycleNum == CYCLE_LIMIT || (axesConverged && paddingConverged);\n\n\t\t\tif (!converged) {\n\t\t\t\tcalcSize(self.width, self.height);\n\t\t\t\tshouldSetSize = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSize({width, height}) {\n\t\t_setSize(width, height);\n\t}\n\n\tself.setSize = setSize;\n\n\t// accumulate axis offsets, reduce canvas width\n\tfunction calcPlotRect() {\n\t\t// easements for edge labels\n\t\tlet hasTopAxis = false;\n\t\tlet hasBtmAxis = false;\n\t\tlet hasRgtAxis = false;\n\t\tlet hasLftAxis = false;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet {side, _size} = axis;\n\t\t\t\tlet isVt = side % 2;\n\t\t\t\tlet labelSize = axis.label != null ? axis.labelSize : 0;\n\n\t\t\t\tlet fullSize = _size + labelSize;\n\n\t\t\t\tif (fullSize > 0) {\n\t\t\t\t\tif (isVt) {\n\t\t\t\t\t\tplotWidCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 3) {\n\t\t\t\t\t\t\tplotLftCss += fullSize;\n\t\t\t\t\t\t\thasLftAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasRgtAxis = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tplotHgtCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 0) {\n\t\t\t\t\t\t\tplotTopCss += fullSize;\n\t\t\t\t\t\t\thasTopAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasBtmAxis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsidesWithAxes[0] = hasTopAxis;\n\t\tsidesWithAxes[1] = hasRgtAxis;\n\t\tsidesWithAxes[2] = hasBtmAxis;\n\t\tsidesWithAxes[3] = hasLftAxis;\n\n\t\t// hz padding\n\t\tplotWidCss -= _padding[1] + _padding[3];\n\t\tplotLftCss += _padding[3];\n\n\t\t// vt padding\n\t\tplotHgtCss -= _padding[2] + _padding[0];\n\t\tplotTopCss += _padding[0];\n\t}\n\n\tfunction calcAxesRects() {\n\t\t// will accum +\n\t\tlet off1 = plotLftCss + plotWidCss;\n\t\tlet off2 = plotTopCss + plotHgtCss;\n\t\t// will accum -\n\t\tlet off3 = plotLftCss;\n\t\tlet off0 = plotTopCss;\n\n\t\tfunction incrOffset(side, size) {\n\t\t\tswitch (side) {\n\t\t\t\tcase 1: off1 += size; return off1 - size;\n\t\t\t\tcase 2: off2 += size; return off2 - size;\n\t\t\t\tcase 3: off3 -= size; return off3 + size;\n\t\t\t\tcase 0: off0 -= size; return off0 + size;\n\t\t\t}\n\t\t}\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet side = axis.side;\n\n\t\t\t\taxis._pos = incrOffset(side, axis._size);\n\n\t\t\t\tif (axis.label != null)\n\t\t\t\t\taxis._lpos = incrOffset(side, axis.labelSize);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst cursor = (self.cursor = assign({}, cursorOpts, {drag: {y: mode == 2}}, opts.cursor));\n\n\t{\n\t\tcursor.idxs = activeIdxs;\n\n\t\tcursor._lock = false;\n\n\t\tlet points = cursor.points;\n\n\t\tpoints.show   = fnOrSelf(points.show);\n\t\tpoints.size   = fnOrSelf(points.size);\n\t\tpoints.stroke = fnOrSelf(points.stroke);\n\t\tpoints.width  = fnOrSelf(points.width);\n\t\tpoints.fill   = fnOrSelf(points.fill);\n\t}\n\n\tconst focus = self.focus = assign({}, opts.focus || {alpha: 0.3}, cursor.focus);\n\tconst cursorFocus = focus.prox >= 0;\n\n\t// series-intersection markers\n\tlet cursorPts = [null];\n\n\tfunction initCursorPt(s, si) {\n\t\tif (si > 0) {\n\t\t\tlet pt = cursor.points.show(self, si);\n\n\t\t\tif (pt) {\n\t\t\t\taddClass(pt, CURSOR_PT);\n\t\t\t\taddClass(pt, s.class);\n\t\t\t\telTrans(pt, -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\tover.insertBefore(pt, cursorPts[si]);\n\n\t\t\t\treturn pt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initSeries(s, i) {\n\t\tif (mode == 1 || i > 0) {\n\t\t\tlet isTime = mode == 1 && scales[s.scale].time;\n\n\t\t\tlet sv = s.value;\n\t\t\ts.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;\n\t\t\ts.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);\n\t\t}\n\n\t\tif (i > 0) {\n\t\t\ts.width  = s.width == null ? 1 : s.width;\n\t\t\ts.paths  = s.paths || linearPath || retNull;\n\t\t\ts.fillTo = fnOrSelf(s.fillTo || seriesFillTo);\n\t\t\ts.pxAlign = +ifNull(s.pxAlign, pxAlign);\n\t\t\ts.pxRound = pxRoundGen(s.pxAlign);\n\n\t\t\ts.stroke = fnOrSelf(s.stroke || null);\n\t\t\ts.fill   = fnOrSelf(s.fill || null);\n\t\t\ts._stroke = s._fill = s._paths = s._focus = null;\n\n\t\t\tlet _ptDia = ptDia(s.width, 1);\n\t\t\tlet points = s.points = assign({}, {\n\t\t\t\tsize: _ptDia,\n\t\t\t\twidth: max(1, _ptDia * .2),\n\t\t\t\tstroke: s.stroke,\n\t\t\t\tspace: _ptDia * 2,\n\t\t\t\tpaths: pointsPath,\n\t\t\t\t_stroke: null,\n\t\t\t\t_fill: null,\n\t\t\t}, s.points);\n\t\t\tpoints.show   = fnOrSelf(points.show);\n\t\t\tpoints.filter = fnOrSelf(points.filter);\n\t\t\tpoints.fill   = fnOrSelf(points.fill);\n\t\t\tpoints.stroke = fnOrSelf(points.stroke);\n\t\t\tpoints.paths  = fnOrSelf(points.paths);\n\t\t\tpoints.pxAlign = s.pxAlign;\n\t\t}\n\n\t\tif (showLegend) {\n\t\t\tlet rowCells = initLegendRow(s, i);\n\t\t\tlegendRows.splice(i, 0, rowCells[0]);\n\t\t\tlegendCells.splice(i, 0, rowCells[1]);\n\t\t\tlegend.values.push(null);\t// NULL_LEGEND_VALS not yet avil here :(\n\t\t}\n\n\t\tif (cursor.show) {\n\t\t\tactiveIdxs.splice(i, 0, null);\n\n\t\t\tlet pt = initCursorPt(s, i);\n\t\t\tpt && cursorPts.splice(i, 0, pt);\n\t\t}\n\n\t\tfire(\"addSeries\", i);\n\t}\n\n\tfunction addSeries(opts, si) {\n\t\tsi = si == null ? series.length : si;\n\n\t\topts = setDefault(opts, si, xSeriesOpts, ySeriesOpts);\n\t\tseries.splice(si, 0, opts);\n\t\tinitSeries(series[si], si);\n\t}\n\n\tself.addSeries = addSeries;\n\n\tfunction delSeries(i) {\n\t\tseries.splice(i, 1);\n\n\t\tif (showLegend) {\n\t\t\tlegend.values.splice(i, 1);\n\n\t\t\tlegendCells.splice(i, 1);\n\t\t\tlet tr = legendRows.splice(i, 1)[0];\n\t\t\toffMouse(null, tr.firstChild);\n\t\t\ttr.remove();\n\t\t}\n\n\t\tif (cursor.show) {\n\t\t\tactiveIdxs.splice(i, 1);\n\n\t\t\tcursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();\n\t\t}\n\n\t\t// TODO: de-init no-longer-needed scales?\n\n\t\tfire(\"delSeries\", i);\n\t}\n\n\tself.delSeries = delSeries;\n\n\tconst sidesWithAxes = [false, false, false, false];\n\n\tfunction initAxis(axis, i) {\n\t\taxis._show = axis.show;\n\n\t\tif (axis.show) {\n\t\t\tlet isVt = axis.side % 2;\n\n\t\t\tlet sc = scales[axis.scale];\n\n\t\t\t// this can occur if all series specify non-default scales\n\t\t\tif (sc == null) {\n\t\t\t\taxis.scale = isVt ? series[1].scale : xScaleKey;\n\t\t\t\tsc = scales[axis.scale];\n\t\t\t}\n\n\t\t\t// also set defaults for incrs & values based on axis distr\n\t\t\tlet isTime = sc.time;\n\n\t\t\taxis.size   = fnOrSelf(axis.size);\n\t\t\taxis.space  = fnOrSelf(axis.space);\n\t\t\taxis.rotate = fnOrSelf(axis.rotate);\n\t\t\taxis.incrs  = fnOrSelf(axis.incrs  || (          sc.distr == 2 ? wholeIncrs : (isTime ? (ms == 1 ? timeIncrsMs : timeIncrsS) : numIncrs)));\n\t\t\taxis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));\n\n\t\t\taxis.stroke        = fnOrSelf(axis.stroke);\n\t\t\taxis.grid.stroke   = fnOrSelf(axis.grid.stroke);\n\t\t\taxis.ticks.stroke  = fnOrSelf(axis.ticks.stroke);\n\t\t\taxis.border.stroke = fnOrSelf(axis.border.stroke);\n\n\t\t\tlet av = axis.values;\n\n\t\t\taxis.values = (\n\t\t\t\t// static array of tick values\n\t\t\t\tisArr(av) && !isArr(av[0]) ? fnOrSelf(av) :\n\t\t\t\t// temporal\n\t\t\t\tisTime ? (\n\t\t\t\t\t// config array of fmtDate string tpls\n\t\t\t\t\tisArr(av) ?\n\t\t\t\t\t\ttimeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) :\n\t\t\t\t\t// fmtDate string tpl\n\t\t\t\t\tisStr(av) ?\n\t\t\t\t\t\ttimeAxisVal(_tzDate, av) :\n\t\t\t\t\tav || _timeAxisVals\n\t\t\t\t) : av || numAxisVals\n\t\t\t);\n\n\t\t\taxis.filter = fnOrSelf(axis.filter || (          sc.distr >= 3 ? logAxisValsFilt : retArg1));\n\n\t\t\taxis.font      = pxRatioFont(axis.font);\n\t\t\taxis.labelFont = pxRatioFont(axis.labelFont);\n\n\t\t\taxis._size   = axis.size(self, null, i, 0);\n\n\t\t\taxis._space  =\n\t\t\taxis._rotate =\n\t\t\taxis._incrs  =\n\t\t\taxis._found  =\t// foundIncrSpace\n\t\t\taxis._splits =\n\t\t\taxis._values = null;\n\n\t\t\tif (axis._size > 0) {\n\t\t\t\tsidesWithAxes[i] = true;\n\t\t\t\taxis._el = placeDiv(AXIS, wrap);\n\t\t\t}\n\n\t\t\t// debug\n\t\t//\taxis._el.style.background = \"#\"  + Math.floor(Math.random()*16777215).toString(16) + '80';\n\t\t}\n\t}\n\n\tfunction autoPadSide(self, side, sidesWithAxes, cycleNum) {\n\t\tlet [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes;\n\n\t\tlet ori = side % 2;\n\t\tlet size = 0;\n\n\t\tif (ori == 0 && (hasLftAxis || hasRgtAxis))\n\t\t\tsize = (side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0);\n\t\tif (ori == 1 && (hasTopAxis || hasBtmAxis))\n\t\t\tsize = (side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0);\n\n\t\treturn size;\n\t}\n\n\tconst padding = self.padding = (opts.padding || [autoPadSide,autoPadSide,autoPadSide,autoPadSide]).map(p => fnOrSelf(ifNull(p, autoPadSide)));\n\tconst _padding = self._padding = padding.map((p, i) => p(self, i, sidesWithAxes, 0));\n\n\tlet dataLen;\n\n\t// rendered data window\n\tlet i0 = null;\n\tlet i1 = null;\n\tconst idxs = mode == 1 ? series[0].idxs : null;\n\n\tlet data0 = null;\n\n\tlet viaAutoScaleX = false;\n\n\tfunction setData(_data, _resetScales) {\n\t\tdata = _data == null ? [] : copy(_data, fastIsObj);\n\n\t\tif (mode == 2) {\n\t\t\tdataLen = 0;\n\t\t\tfor (let i = 1; i < series.length; i++)\n\t\t\t\tdataLen += data[i][0].length;\n\t\t\tself.data = data = _data;\n\t\t}\n\t\telse {\n\t\t\tif (data[0] == null)\n\t\t\t\tdata[0] = [];\n\n\t\t\tself.data = data.slice();\n\n\t\t\tdata0 = data[0];\n\t\t\tdataLen = data0.length;\n\n\t\t\tif (xScaleDistr == 2) {\n\t\t\t\tdata[0] = Array(dataLen);\n\t\t\t\tfor (let i = 0; i < dataLen; i++)\n\t\t\t\t\tdata[0][i] = i;\n\t\t\t}\n\t\t}\n\n\t\tself._data = data;\n\n\t\tresetYSeries(true);\n\n\t\tfire(\"setData\");\n\n\t\t// forces x axis tick values to re-generate when neither x scale nor y scale changes\n\t\t// in ordinal mode, scale range is by index, so will not change if new data has same length, but tick values are from data\n\t\tif (xScaleDistr == 2) {\n\t\t\tshouldConvergeSize = true;\n\n\t\t\t/* or somewhat cheaper, and uglier:\n\t\t\tif (ready) {\n\t\t\t\t// logic extracted from axesCalc()\n\t\t\t\tlet i = 0;\n\t\t\t\tlet axis = axes[i];\n\t\t\t\tlet _splits = axis._splits.map(i => data0[i]);\n\t\t\t\tlet [_incr, _space] = axis._found;\n\t\t\t\tlet incr = data0[_splits[1]] - data0[_splits[0]];\n\t\t\t\taxis._values = axis.values(self, axis.filter(self, _splits, i, _space, incr), i, _space, incr);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\tif (_resetScales !== false) {\n\t\t\tlet xsc = scaleX;\n\n\t\t\tif (xsc.auto(self, viaAutoScaleX))\n\t\t\t\tautoScaleX();\n\t\t\telse\n\t\t\t\t_setScale(xScaleKey, xsc.min, xsc.max);\n\n\t\t\tshouldSetCursor = cursor.left >= 0;\n\t\t\tshouldSetLegend = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setData = setData;\n\n\tfunction autoScaleX() {\n\t\tviaAutoScaleX = true;\n\n\t\tlet _min, _max;\n\n\t\tif (mode == 1) {\n\t\t\tif (dataLen > 0) {\n\t\t\t\ti0 = idxs[0] = 0;\n\t\t\t\ti1 = idxs[1] = dataLen - 1;\n\n\t\t\t\t_min = data[0][i0];\n\t\t\t\t_max = data[0][i1];\n\n\t\t\t\tif (xScaleDistr == 2) {\n\t\t\t\t\t_min = i0;\n\t\t\t\t\t_max = i1;\n\t\t\t\t}\n\t\t\t\telse if (dataLen == 1) {\n\t\t\t\t\tif (xScaleDistr == 3)\n\t\t\t\t\t\t[_min, _max] = rangeLog(_min, _min, scaleX.log, false);\n\t\t\t\t\telse if (xScaleDistr == 4)\n\t\t\t\t\t\t[_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);\n\t\t\t\t\telse if (scaleX.time)\n\t\t\t\t\t\t_max = _min + round(86400 / ms);\n\t\t\t\t\telse\n\t\t\t\t\t\t[_min, _max] = rangeNum(_min, _max, rangePad, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti0 = idxs[0] = _min = null;\n\t\t\t\ti1 = idxs[1] = _max = null;\n\t\t\t}\n\t\t}\n\n\t\t_setScale(xScaleKey, _min, _max);\n\t}\n\n\tlet ctxStroke, ctxFill, ctxWidth, ctxDash, ctxJoin, ctxCap, ctxFont, ctxAlign, ctxBaseline;\n\tlet ctxAlpha;\n\n\tfunction setCtxStyle(stroke = transparent, width, dash = EMPTY_ARR, cap = \"butt\", fill = transparent, join = \"round\") {\n\t\tif (stroke != ctxStroke)\n\t\t\tctx.strokeStyle = ctxStroke = stroke;\n\t\tif (fill != ctxFill)\n\t\t\tctx.fillStyle = ctxFill = fill;\n\t\tif (width != ctxWidth)\n\t\t\tctx.lineWidth = ctxWidth = width;\n\t\tif (join != ctxJoin)\n\t\t\tctx.lineJoin = ctxJoin = join;\n\t\tif (cap != ctxCap)\n\t\t\tctx.lineCap = ctxCap = cap; // (\u203F|\u203F)\n\t\tif (dash != ctxDash)\n\t\t\tctx.setLineDash(ctxDash = dash);\n\t}\n\n\tfunction setFontStyle(font, fill, align, baseline) {\n\t\tif (fill != ctxFill)\n\t\t\tctx.fillStyle = ctxFill = fill;\n\t\tif (font != ctxFont)\n\t\t\tctx.font = ctxFont = font;\n\t\tif (align != ctxAlign)\n\t\t\tctx.textAlign = ctxAlign = align;\n\t\tif (baseline != ctxBaseline)\n\t\t\tctx.textBaseline = ctxBaseline = baseline;\n\t}\n\n\tfunction accScale(wsc, psc, facet, data, sorted = 0) {\n\t\tif (data.length > 0 && wsc.auto(self, viaAutoScaleX) && (psc == null || psc.min == null)) {\n\t\t\tlet _i0 = ifNull(i0, 0);\n\t\t\tlet _i1 = ifNull(i1, data.length - 1);\n\n\t\t\t// only run getMinMax() for invalidated series data, else reuse\n\t\t\tlet minMax = facet.min == null ? (wsc.distr == 3 ? getMinMaxLog(data, _i0, _i1) : getMinMax(data, _i0, _i1, sorted)) : [facet.min, facet.max];\n\n\t\t\t// initial min/max\n\t\t\twsc.min = min(wsc.min, facet.min = minMax[0]);\n\t\t\twsc.max = max(wsc.max, facet.max = minMax[1]);\n\t\t}\n\t}\n\n\tfunction setScales() {\n\t//\tlog(\"setScales()\", arguments);\n\n\t\t// wip scales\n\t\tlet wipScales = copy(scales, fastIsObj);\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet psc = pendScales[k];\n\n\t\t\tif (psc != null && psc.min != null) {\n\t\t\t\tassign(wsc, psc);\n\n\t\t\t\t// explicitly setting the x-scale invalidates everything (acts as redraw)\n\t\t\t\tif (k == xScaleKey)\n\t\t\t\t\tresetYSeries(true);\n\t\t\t}\n\t\t\telse if (k != xScaleKey || mode == 2) {\n\t\t\t\tif (dataLen == 0 && wsc.from == null) {\n\t\t\t\t\tlet minMax = wsc.range(self, null, null, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twsc.min = inf;\n\t\t\t\t\twsc.max = -inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dataLen > 0) {\n\t\t\t// pre-range y-scales from y series' data values\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (mode == 1) {\n\t\t\t\t\tlet k = s.scale;\n\t\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\tlet minMax = wsc.range(self, wsc.min, wsc.max, k);\n\n\t\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\t\twsc.max = minMax[1];\n\n\t\t\t\t\t\ti0 = closestIdx(wsc.min, data[0]);\n\t\t\t\t\t\ti1 = closestIdx(wsc.max, data[0]);\n\n\t\t\t\t\t\t// closest indices can be outside of view\n\t\t\t\t\t\tif (data[0][i0] < wsc.min)\n\t\t\t\t\t\t\ti0++;\n\t\t\t\t\t\tif (data[0][i1] > wsc.max)\n\t\t\t\t\t\t\ti1--;\n\n\t\t\t\t\t\ts.min = data0[i0];\n\t\t\t\t\t\ts.max = data0[i1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (s.show && s.auto)\n\t\t\t\t\t\taccScale(wsc, psc, s, data[i], s.sorted);\n\n\t\t\t\t\ts.idxs[0] = i0;\n\t\t\t\t\ts.idxs[1] = i1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tif (s.show && s.auto) {\n\t\t\t\t\t\t\t// TODO: only handles, assumes and requires facets[0] / 'x' scale, and facets[1] / 'y' scale\n\t\t\t\t\t\t\tlet [ xFacet, yFacet ] = s.facets;\n\t\t\t\t\t\t\tlet xScaleKey = xFacet.scale;\n\t\t\t\t\t\t\tlet yScaleKey = yFacet.scale;\n\t\t\t\t\t\t\tlet [ xData, yData ] = data[i];\n\n\t\t\t\t\t\t\taccScale(wipScales[xScaleKey], pendScales[xScaleKey], xFacet, xData, xFacet.sorted);\n\t\t\t\t\t\t\taccScale(wipScales[yScaleKey], pendScales[yScaleKey], yFacet, yData, yFacet.sorted);\n\n\t\t\t\t\t\t\t// temp\n\t\t\t\t\t\t\ts.min = yFacet.min;\n\t\t\t\t\t\t\ts.max = yFacet.max;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// range independent scales\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\tif (wsc.from == null && (psc == null || psc.min == null)) {\n\t\t\t\t\tlet minMax = wsc.range(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\twsc.min ==  inf ? null : wsc.min,\n\t\t\t\t\t\twsc.max == -inf ? null : wsc.max,\n\t\t\t\t\t\tk\n\t\t\t\t\t);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// range dependent scales\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\n\t\t\tif (wsc.from != null) {\n\t\t\t\tlet base = wipScales[wsc.from];\n\n\t\t\t\tif (base.min == null)\n\t\t\t\t\twsc.min = wsc.max = null;\n\t\t\t\telse {\n\t\t\t\t\tlet minMax = wsc.range(self, base.min, base.max, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet changed = {};\n\t\tlet anyChanged = false;\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet sc = scales[k];\n\n\t\t\tif (sc.min != wsc.min || sc.max != wsc.max) {\n\t\t\t\tsc.min = wsc.min;\n\t\t\t\tsc.max = wsc.max;\n\n\t\t\t\tlet distr = sc.distr;\n\n\t\t\t\tsc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;\n\t\t\t\tsc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;\n\n\t\t\t\tchanged[k] = anyChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (anyChanged) {\n\t\t\t// invalidate paths of all series on changed scales\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (mode == 2) {\n\t\t\t\t\tif (i > 0 && changed.y)\n\t\t\t\t\t\ts._paths = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changed[s.scale])\n\t\t\t\t\t\ts._paths = null;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (let k in changed) {\n\t\t\t\tshouldConvergeSize = true;\n\t\t\t\tfire(\"setScale\", k);\n\t\t\t}\n\n\t\t\tif (cursor.show)\n\t\t\t\tshouldSetCursor = shouldSetLegend = cursor.left >= 0;\n\t\t}\n\n\t\tfor (let k in pendScales)\n\t\t\tpendScales[k] = null;\n\t}\n\n\t// grabs the nearest indices with y data outside of x-scale limits\n\tfunction getOuterIdxs(ydata) {\n\t\tlet _i0 = clamp(i0 - 1, 0, dataLen - 1);\n\t\tlet _i1 = clamp(i1 + 1, 0, dataLen - 1);\n\n\t\twhile (ydata[_i0] == null && _i0 > 0)\n\t\t\t_i0--;\n\n\t\twhile (ydata[_i1] == null && _i1 < dataLen - 1)\n\t\t\t_i1++;\n\n\t\treturn [_i0, _i1];\n\t}\n\n\tfunction drawSeries() {\n\t\tif (dataLen > 0) {\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show && s._paths == null) {\n\t\t\t\t\tlet _idxs = getOuterIdxs(data[i]);\n\t\t\t\t\ts._paths = s.paths(self, i, _idxs[0], _idxs[1]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tif (ctxAlpha != s.alpha)\n\t\t\t\t\t\tctx.globalAlpha = ctxAlpha = s.alpha;\n\n\t\t\t\t\t{\n\t\t\t\t\t\tcacheStrokeFill(i, false);\n\t\t\t\t\t\ts._paths && drawPath(i, false);\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t\tcacheStrokeFill(i, true);\n\n\t\t\t\t\t\tlet show = s.points.show(self, i, i0, i1);\n\t\t\t\t\t\tlet idxs = s.points.filter(self, i, show, s._paths ? s._paths.gaps : null);\n\n\t\t\t\t\t\tif (show || idxs) {\n\t\t\t\t\t\t\ts.points._paths = s.points.paths(self, i, i0, i1, idxs);\n\t\t\t\t\t\t\tdrawPath(i, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ctxAlpha != 1)\n\t\t\t\t\t\tctx.globalAlpha = ctxAlpha = 1;\n\n\t\t\t\t\tfire(\"drawSeries\", i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction cacheStrokeFill(si, _points) {\n\t\tlet s = _points ? series[si].points : series[si];\n\n\t\ts._stroke = s.stroke(self, si);\n\t\ts._fill   = s.fill(self, si);\n\t}\n\n\tfunction drawPath(si, _points) {\n\t\tlet s = _points ? series[si].points : series[si];\n\n\t\tlet strokeStyle = s._stroke;\n\t\tlet fillStyle   = s._fill;\n\n\t\tlet { stroke, fill, clip: gapsClip, flags } = s._paths;\n\t\tlet boundsClip = null;\n\t\tlet width = roundDec(s.width * pxRatio, 3);\n\t\tlet offset = (width % 2) / 2;\n\n\t\tif (_points && fillStyle == null)\n\t\t\tfillStyle = width > 0 ? \"#fff\" : strokeStyle;\n\n\t\tlet _pxAlign = s.pxAlign == 1;\n\n\t\t_pxAlign && ctx.translate(offset, offset);\n\n\t\tif (!_points) {\n\t\t\tlet lft = plotLft,\n\t\t\t\ttop = plotTop,\n\t\t\t\twid = plotWid,\n\t\t\t\thgt = plotHgt;\n\n\t\t\tlet halfWid = width * pxRatio / 2;\n\n\t\t\tif (s.min == 0)\n\t\t\t\thgt += halfWid;\n\n\t\t\tif (s.max == 0) {\n\t\t\t\ttop -= halfWid;\n\t\t\t\thgt += halfWid;\n\t\t\t}\n\n\t\t\tboundsClip = new Path2D();\n\t\t\tboundsClip.rect(lft, top, wid, hgt);\n\t\t}\n\n\t\t// the points pathbuilder's gapsClip is its boundsClip, since points dont need gaps clipping, and bounds depend on point size\n\t\tif (_points)\n\t\t\tstrokeFill(strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, gapsClip);\n\t\telse\n\t\t\tfillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, boundsClip, gapsClip);\n\n\t\t_pxAlign && ctx.translate(-offset, -offset);\n\t}\n\n\tfunction fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip) {\n\t\tlet didStrokeFill = false;\n\n\t\t// for all bands where this series is the top edge, create upwards clips using the bottom edges\n\t\t// and apply clips + fill with band fill or dfltFill\n\t\tbands.forEach((b, bi) => {\n\t\t\t// isUpperEdge?\n\t\t\tif (b.series[0] == si) {\n\t\t\t\tlet lowerEdge = series[b.series[1]];\n\t\t\t\tlet lowerData = data[b.series[1]];\n\n\t\t\t\tlet bandClip = (lowerEdge._paths || EMPTY_OBJ).band;\n\n\t\t\t\tif (isArr(bandClip))\n\t\t\t\t\tbandClip = b.dir == 1 ? bandClip[0] : bandClip[1];\n\n\t\t\t\tlet gapsClip2;\n\n\t\t\t\tlet _fillStyle = null;\n\n\t\t\t\t// hasLowerEdge?\n\t\t\t\tif (lowerEdge.show && bandClip && hasData(lowerData, i0, i1)) {\n\t\t\t\t\t_fillStyle = b.fill(self, bi) || fillStyle;\n\t\t\t\t\tgapsClip2 = lowerEdge._paths.clip;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbandClip = null;\n\n\t\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip);\n\n\t\t\t\tdidStrokeFill = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!didStrokeFill)\n\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip);\n\t}\n\n\tconst CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;\n\n\tfunction strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip) {\n\t\tsetCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);\n\n\t\tif (boundsClip || gapsClip || bandClip) {\n\t\t\tctx.save();\n\t\t\tboundsClip && ctx.clip(boundsClip);\n\t\t\tgapsClip && ctx.clip(gapsClip);\n\t\t}\n\n\t\tif (bandClip) {\n\t\t\tif ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tgapsClip2 && ctx.clip(gapsClip2);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_STROKE) {\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_FILL) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tgapsClip2 && ctx.clip(gapsClip2);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.restore();\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoFill(fillStyle, fillPath);\n\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t}\n\n\t\tif (boundsClip || gapsClip || bandClip)\n\t\t\tctx.restore();\n\t}\n\n\tfunction doStroke(strokeStyle, strokePath, lineWidth) {\n\t\tif (lineWidth > 0) {\n\t\t\tif (strokePath instanceof Map) {\n\t\t\t\tstrokePath.forEach((strokePath, strokeStyle) => {\n\t\t\t\t\tctx.strokeStyle = ctxStroke = strokeStyle;\n\t\t\t\t\tctx.stroke(strokePath);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrokePath != null && strokeStyle && ctx.stroke(strokePath);\n\t\t}\n\t}\n\n\tfunction doFill(fillStyle, fillPath) {\n\t\tif (fillPath instanceof Map) {\n\t\t\tfillPath.forEach((fillPath, fillStyle) => {\n\t\t\t\tctx.fillStyle = ctxFill = fillStyle;\n\t\t\t\tctx.fill(fillPath);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t\tfillPath != null && fillStyle && ctx.fill(fillPath);\n\t}\n\n\tfunction getIncrSpace(axisIdx, min, max, fullDim) {\n\t\tlet axis = axes[axisIdx];\n\n\t\tlet incrSpace;\n\n\t\tif (fullDim <= 0)\n\t\t\tincrSpace = [0, 0];\n\t\telse {\n\t\t\tlet minSpace = axis._space = axis.space(self, axisIdx, min, max, fullDim);\n\t\t\tlet incrs    = axis._incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);\n\t\t\tincrSpace    = findIncr(min, max, incrs, fullDim, minSpace);\n\t\t}\n\n\t\treturn (axis._found = incrSpace);\n\t}\n\n\tfunction drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {\n\t\tlet offset = (width % 2) / 2;\n\n\t\tpxAlign == 1 && ctx.translate(offset, offset);\n\n\t\tsetCtxStyle(stroke, width, dash, cap, stroke);\n\n\t\tctx.beginPath();\n\n\t\tlet x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);\n\n\t\tif (ori == 0) {\n\t\t\ty0 = pos0;\n\t\t\ty1 = pos1;\n\t\t}\n\t\telse {\n\t\t\tx0 = pos0;\n\t\t\tx1 = pos1;\n\t\t}\n\n\t\tfor (let i = 0; i < offs.length; i++) {\n\t\t\tif (filts[i] != null) {\n\t\t\t\tif (ori == 0)\n\t\t\t\t\tx0 = x1 = offs[i];\n\t\t\t\telse\n\t\t\t\t\ty0 = y1 = offs[i];\n\n\t\t\t\tctx.moveTo(x0, y0);\n\t\t\t\tctx.lineTo(x1, y1);\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tpxAlign == 1 && ctx.translate(-offset, -offset);\n\t}\n\n\tfunction axesCalc(cycleNum) {\n\t//\tlog(\"axesCalc()\", arguments);\n\n\t\tlet converged = true;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (!axis.show)\n\t\t\t\treturn;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\tif (scale.min == null) {\n\t\t\t\tif (axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = false;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = true;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet {min, max} = scale;\t\t// \t\t// should this toggle them ._show = false\n\n\t\t\tlet [_incr, _space] = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);\n\n\t\t\tif (_space == 0)\n\t\t\t\treturn;\n\n\t\t\t// if we're using index positions, force first tick to match passed index\n\t\t\tlet forceMin = scale.distr == 2;\n\n\t\t\tlet _splits = axis._splits = axis.splits(self, i, min, max, _incr, _space, forceMin);\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet values = axis._values = axis.values(self, axis.filter(self, splits, i, _space, incr), i, _space, incr);\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\taxis._rotate = side == 2 ? axis.rotate(self, values, i, _space) : 0;\n\n\t\t\tlet oldSize = axis._size;\n\n\t\t\taxis._size = ceil(axis.size(self, values, i, cycleNum));\n\n\t\t\tif (oldSize != null && axis._size != oldSize)\t\t\t// ready && ?\n\t\t\t\tconverged = false;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction paddingCalc(cycleNum) {\n\t\tlet converged = true;\n\n\t\tpadding.forEach((p, i) => {\n\t\t\tlet _p = p(self, i, sidesWithAxes, cycleNum);\n\n\t\t\tif (_p != _padding[i])\n\t\t\t\tconverged = false;\n\n\t\t\t_padding[i] = _p;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction drawAxesGrid() {\n\t\tfor (let i = 0; i < axes.length; i++) {\n\t\t\tlet axis = axes[i];\n\n\t\t\tif (!axis.show || !axis._show)\n\t\t\t\tcontinue;\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet x, y;\n\n\t\t\tlet fillStyle = axis.stroke(self, i);\n\n\t\t\tlet shiftDir = side == 0 || side == 3 ? -1 : 1;\n\n\t\t\t// axis label\n\t\t\tif (axis.label) {\n\t\t\t\tlet shiftAmt = axis.labelGap * shiftDir;\n\t\t\t\tlet baseLpos = round((axis._lpos + shiftAmt) * pxRatio);\n\n\t\t\t\tsetFontStyle(axis.labelFont[0], fillStyle, \"center\", side == 2 ? TOP : BOTTOM);\n\n\t\t\t\tctx.save();\n\n\t\t\t\tif (ori == 1) {\n\t\t\t\t\tx = y = 0;\n\n\t\t\t\t\tctx.translate(\n\t\t\t\t\t\tbaseLpos,\n\t\t\t\t\t\tround(plotTop + plotHgt / 2),\n\t\t\t\t\t);\n\t\t\t\t\tctx.rotate((side == 3 ? -PI : PI) / 2);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = round(plotLft + plotWid / 2);\n\t\t\t\t\ty = baseLpos;\n\t\t\t\t}\n\n\t\t\t\tctx.fillText(axis.label, x, y);\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tlet [_incr, _space] = axis._found;\n\n\t\t\tif (_space == 0)\n\t\t\t\tcontinue;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\tlet plotDim = ori == 0 ? plotWid : plotHgt;\n\t\t\tlet plotOff = ori == 0 ? plotLft : plotTop;\n\n\t\t\tlet axisGap = round(axis.gap * pxRatio);\n\n\t\t\tlet _splits = axis._splits;\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet ticks = axis.ticks;\n\t\t\tlet border = axis.border;\n\t\t\tlet tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\tlet angle = axis._rotate * -PI/180;\n\n\t\t\tlet basePos  = pxRound(axis._pos * pxRatio);\n\t\t\tlet shiftAmt = (tickSize + axisGap) * shiftDir;\n\t\t\tlet finalPos = basePos + shiftAmt;\n\t\t\t    y        = ori == 0 ? finalPos : 0;\n\t\t\t    x        = ori == 1 ? finalPos : 0;\n\n\t\t\tlet font         = axis.font[0];\n\t\t\tlet textAlign    = axis.align == 1 ? LEFT :\n\t\t\t                   axis.align == 2 ? RIGHT :\n\t\t\t                   angle > 0 ? LEFT :\n\t\t\t                   angle < 0 ? RIGHT :\n\t\t\t                   ori == 0 ? \"center\" : side == 3 ? RIGHT : LEFT;\n\t\t\tlet textBaseline = angle ||\n\t\t\t                   ori == 1 ? \"middle\" : side == 2 ? TOP   : BOTTOM;\n\n\t\t\tsetFontStyle(font, fillStyle, textAlign, textBaseline);\n\n\t\t\tlet lineHeight = axis.font[1] * lineMult;\n\n\t\t\tlet canOffs = _splits.map(val => pxRound(getPos(val, scale, plotDim, plotOff)));\n\n\t\t\tlet _values = axis._values;\n\n\t\t\tfor (let i = 0; i < _values.length; i++) {\n\t\t\t\tlet val = _values[i];\n\n\t\t\t\tif (val != null) {\n\t\t\t\t\tif (ori == 0)\n\t\t\t\t\t\tx = canOffs[i];\n\t\t\t\t\telse\n\t\t\t\t\t\ty = canOffs[i];\n\n\t\t\t\t\tval = \"\" + val;\n\n\t\t\t\t\tlet _parts = val.indexOf(\"\\n\") == -1 ? [val] : val.split(/\\n/gm);\n\n\t\t\t\t\tfor (let j = 0; j < _parts.length; j++) {\n\t\t\t\t\t\tlet text = _parts[j];\n\n\t\t\t\t\t\tif (angle) {\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(x, y + j * lineHeight); // can this be replaced with position math?\n\t\t\t\t\t\t\tctx.rotate(angle); // can this be done once?\n\t\t\t\t\t\t\tctx.fillText(text, 0, 0);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tctx.fillText(text, x, y + j * lineHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ticks\n\t\t\tif (ticks.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tticks.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tside,\n\t\t\t\t\tbasePos,\n\t\t\t\t\ttickSize,\n\t\t\t\t\troundDec(ticks.width * pxRatio, 3),\n\t\t\t\t\tticks.stroke(self, i),\n\t\t\t\t\tticks.dash,\n\t\t\t\t\tticks.cap,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// grid\n\t\t\tlet grid = axis.grid;\n\n\t\t\tif (grid.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tgrid.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tori == 0 ? 2 : 1,\n\t\t\t\t\tori == 0 ? plotTop : plotLft,\n\t\t\t\t\tori == 0 ? plotHgt : plotWid,\n\t\t\t\t\troundDec(grid.width * pxRatio, 3),\n\t\t\t\t\tgrid.stroke(self, i),\n\t\t\t\t\tgrid.dash,\n\t\t\t\t\tgrid.cap,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (border.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\t[basePos],\n\t\t\t\t\t[1],\n\t\t\t\t\tori == 0 ? 1 : 0,\n\t\t\t\t\tori == 0 ? 1 : 2,\n\t\t\t\t\tori == 1 ? plotTop : plotLft,\n\t\t\t\t\tori == 1 ? plotHgt : plotWid,\n\t\t\t\t\troundDec(border.width * pxRatio, 3),\n\t\t\t\t\tborder.stroke(self, i),\n\t\t\t\t\tborder.dash,\n\t\t\t\t\tborder.cap,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfire(\"drawAxes\");\n\t}\n\n\tfunction resetYSeries(minMax) {\n\t//\tlog(\"resetYSeries()\", arguments);\n\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\ts._paths = null;\n\n\t\t\t\tif (minMax) {\n\t\t\t\t\tif (mode == 1) {\n\t\t\t\t\t\ts.min = null;\n\t\t\t\t\t\ts.max = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ts.facets.forEach(f => {\n\t\t\t\t\t\t\tf.min = null;\n\t\t\t\t\t\t\tf.max = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tlet queuedCommit = false;\n\n\tfunction commit() {\n\t\tif (!queuedCommit) {\n\t\t\tmicroTask(_commit);\n\t\t\tqueuedCommit = true;\n\t\t}\n\t}\n\n\tfunction _commit() {\n\t//\tlog(\"_commit()\", arguments);\n\n\t\tif (shouldSetScales) {\n\t\t\tsetScales();\n\t\t\tshouldSetScales = false;\n\t\t}\n\n\t\tif (shouldConvergeSize) {\n\t\t\tconvergeSize();\n\t\t\tshouldConvergeSize = false;\n\t\t}\n\n\t\tif (shouldSetSize) {\n\t\t\tsetStylePx(under, LEFT,   plotLftCss);\n\t\t\tsetStylePx(under, TOP,    plotTopCss);\n\t\t\tsetStylePx(under, WIDTH,  plotWidCss);\n\t\t\tsetStylePx(under, HEIGHT, plotHgtCss);\n\n\t\t\tsetStylePx(over, LEFT,    plotLftCss);\n\t\t\tsetStylePx(over, TOP,     plotTopCss);\n\t\t\tsetStylePx(over, WIDTH,   plotWidCss);\n\t\t\tsetStylePx(over, HEIGHT,  plotHgtCss);\n\n\t\t\tsetStylePx(wrap, WIDTH,   fullWidCss);\n\t\t\tsetStylePx(wrap, HEIGHT,  fullHgtCss);\n\n\t\t\t// NOTE: mutating this during print preview in Chrome forces transparent\n\t\t\t// canvas pixels to white, even when followed up with clearRect() below\n\t\t\tcan.width  = round(fullWidCss * pxRatio);\n\t\t\tcan.height = round(fullHgtCss * pxRatio);\n\n\t\t\taxes.forEach(({ _el, _show, _size, _pos, side }) => {\n\t\t\t\tif (_el != null) {\n\t\t\t\t\tif (_show) {\n\t\t\t\t\t\tlet posOffset = (side === 3 || side === 0 ? _size : 0);\n\t\t\t\t\t\tlet isVt = side % 2 == 1;\n\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"left\"   : \"top\",    _pos - posOffset);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"width\"  : \"height\", _size);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"top\"    : \"left\",   isVt ? plotTopCss : plotLftCss);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"height\" : \"width\",  isVt ? plotHgtCss : plotWidCss);\n\n\t\t\t\t\t\tremClass(_el, OFF);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\taddClass(_el, OFF);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// invalidate ctx style cache\n\t\t\tctxStroke = ctxFill = ctxWidth = ctxJoin = ctxCap = ctxFont = ctxAlign = ctxBaseline = ctxDash = null;\n\t\t\tctxAlpha = 1;\n\n\t\t\tsyncRect(true);\n\n\t\t\tfire(\"setSize\");\n\n\t\t\tshouldSetSize = false;\n\t\t}\n\n\t\tif (fullWidCss > 0 && fullHgtCss > 0) {\n\t\t\tctx.clearRect(0, 0, can.width, can.height);\n\t\t\tfire(\"drawClear\");\n\t\t\tdrawOrder.forEach(fn => fn());\n\t\t\tfire(\"draw\");\n\t\t}\n\n\t//\tif (shouldSetSelect) {\n\t\t// TODO: update .u-select metrics (if visible)\n\t\t//\tsetStylePx(selectDiv, TOP, select.top = 0);\n\t\t//\tsetStylePx(selectDiv, LEFT, select.left = 0);\n\t\t//\tsetStylePx(selectDiv, WIDTH, select.width = 0);\n\t\t//\tsetStylePx(selectDiv, HEIGHT, select.height = 0);\n\t\t//\tshouldSetSelect = false;\n\t//\t}\n\n\t\tif (cursor.show && shouldSetCursor) {\n\t\t\tupdateCursor(null, true, false);\n\t\t\tshouldSetCursor = false;\n\t\t}\n\n\t//\tif (FEAT_LEGEND && legend.show && legend.live && shouldSetLegend) {}\n\n\t\tif (!ready) {\n\t\t\tready = true;\n\t\t\tself.status = 1;\n\n\t\t\tfire(\"ready\");\n\t\t}\n\n\t\tviaAutoScaleX = false;\n\n\t\tqueuedCommit = false;\n\t}\n\n\tself.redraw = (rebuildPaths, recalcAxes) => {\n\t\tshouldConvergeSize = recalcAxes || false;\n\n\t\tif (rebuildPaths !== false)\n\t\t\t_setScale(xScaleKey, scaleX.min, scaleX.max);\n\t\telse\n\t\t\tcommit();\n\t};\n\n\t// redraw() => setScale('x', scales.x.min, scales.x.max);\n\n\t// explicit, never re-ranged (is this actually true? for x and y)\n\tfunction setScale(key, opts) {\n\t\tlet sc = scales[key];\n\n\t\tif (sc.from == null) {\n\t\t\tif (dataLen == 0) {\n\t\t\t\tlet minMax = sc.range(self, opts.min, opts.max, key);\n\t\t\t\topts.min = minMax[0];\n\t\t\t\topts.max = minMax[1];\n\t\t\t}\n\n\t\t\tif (opts.min > opts.max) {\n\t\t\t\tlet _min = opts.min;\n\t\t\t\topts.min = opts.max;\n\t\t\t\topts.max = _min;\n\t\t\t}\n\n\t\t\tif (dataLen > 1 && opts.min != null && opts.max != null && opts.max - opts.min < 1e-16)\n\t\t\t\treturn;\n\n\t\t\tif (key == xScaleKey) {\n\t\t\t\tif (sc.distr == 2 && dataLen > 0) {\n\t\t\t\t\topts.min = closestIdx(opts.min, data[0]);\n\t\t\t\t\topts.max = closestIdx(opts.max, data[0]);\n\n\t\t\t\t\tif (opts.min == opts.max)\n\t\t\t\t\t\topts.max++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t//\tlog(\"setScale()\", arguments);\n\n\t\t\tpendScales[key] = opts;\n\n\t\t\tshouldSetScales = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setScale = setScale;\n\n//\tINTERACTION\n\n\tlet xCursor;\n\tlet yCursor;\n\tlet vCursor;\n\tlet hCursor;\n\n\t// starting position before cursor.move\n\tlet rawMouseLeft0;\n\tlet rawMouseTop0;\n\n\t// starting position\n\tlet mouseLeft0;\n\tlet mouseTop0;\n\n\t// current position before cursor.move\n\tlet rawMouseLeft1;\n\tlet rawMouseTop1;\n\n\t// current position\n\tlet mouseLeft1;\n\tlet mouseTop1;\n\n\tlet dragging = false;\n\n\tconst drag = cursor.drag;\n\n\tlet dragX = drag.x;\n\tlet dragY = drag.y;\n\n\tif (cursor.show) {\n\t\tif (cursor.x)\n\t\t\txCursor = placeDiv(CURSOR_X, over);\n\t\tif (cursor.y)\n\t\t\tyCursor = placeDiv(CURSOR_Y, over);\n\n\t\tif (scaleX.ori == 0) {\n\t\t\tvCursor = xCursor;\n\t\t\thCursor = yCursor;\n\t\t}\n\t\telse {\n\t\t\tvCursor = yCursor;\n\t\t\thCursor = xCursor;\n\t\t}\n\n\t\tmouseLeft1 = cursor.left;\n\t\tmouseTop1 = cursor.top;\n\t}\n\n\tconst select = self.select = assign({\n\t\tshow:   true,\n\t\tover:   true,\n\t\tleft:   0,\n\t\twidth:  0,\n\t\ttop:    0,\n\t\theight: 0,\n\t}, opts.select);\n\n\tconst selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;\n\n\tfunction setSelect(opts, _fire) {\n\t\tif (select.show) {\n\t\t\tfor (let prop in opts)\n\t\t\t\tsetStylePx(selectDiv, prop, select[prop] = opts[prop]);\n\n\t\t\t_fire !== false && fire(\"setSelect\");\n\t\t}\n\t}\n\n\tself.setSelect = setSelect;\n\n\tfunction toggleDOM(i, onOff) {\n\t\tlet s = series[i];\n\t\tlet label = showLegend ? legendRows[i] : null;\n\n\t\tif (s.show)\n\t\t\tlabel && remClass(label, OFF);\n\t\telse {\n\t\t\tlabel && addClass(label, OFF);\n\t\t\tcursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t}\n\t}\n\n\tfunction _setScale(key, min, max) {\n\t\tsetScale(key, {min, max});\n\t}\n\n\tfunction setSeries(i, opts, _fire, _pub) {\n\t//\tlog(\"setSeries()\", arguments);\n\n\t\tif (opts.focus != null)\n\t\t\tsetFocus(i);\n\n\t\tif (opts.show != null) {\n\t\t\tseries.forEach((s, si) => {\n\t\t\t\tif (si > 0 && (i == si || i == null)) {\n\t\t\t\t\ts.show = opts.show;\n\t\t\t\t\ttoggleDOM(si, opts.show);\n\n\t\t\t\t\t_setScale(mode == 2 ? s.facets[1].scale : s.scale, null, null);\n\t\t\t\t\tcommit();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t_fire !== false && fire(\"setSeries\", i, opts);\n\n\t\t_pub && pubSync(\"setSeries\", self, i, opts);\n\t}\n\n\tself.setSeries = setSeries;\n\n\tfunction setBand(bi, opts) {\n\t\tassign(bands[bi], opts);\n\t}\n\n\tfunction addBand(opts, bi) {\n\t\topts.fill = fnOrSelf(opts.fill || null);\n\t\topts.dir = ifNull(opts.dir, -1);\n\t\tbi = bi == null ? bands.length : bi;\n\t\tbands.splice(bi, 0, opts);\n\t}\n\n\tfunction delBand(bi) {\n\t\tif (bi == null)\n\t\t\tbands.length = 0;\n\t\telse\n\t\t\tbands.splice(bi, 1);\n\t}\n\n\tself.addBand = addBand;\n\tself.setBand = setBand;\n\tself.delBand = delBand;\n\n\tfunction setAlpha(i, value) {\n\t\tseries[i].alpha = value;\n\n\t\tif (cursor.show && cursorPts[i])\n\t\t\tcursorPts[i].style.opacity = value;\n\n\t\tif (showLegend && legendRows[i])\n\t\t\tlegendRows[i].style.opacity = value;\n\t}\n\n\t// y-distance\n\tlet closestDist;\n\tlet closestSeries;\n\tlet focusedSeries;\n\tconst FOCUS_TRUE  = {focus: true};\n\n\tfunction setFocus(i) {\n\t\tif (i != focusedSeries) {\n\t\t//\tlog(\"setFocus()\", arguments);\n\n\t\t\tlet allFocused = i == null;\n\n\t\t\tlet _setAlpha = focus.alpha != 1;\n\n\t\t\tseries.forEach((s, i2) => {\n\t\t\t\tlet isFocused = allFocused || i2 == 0 || i2 == i;\n\t\t\t\ts._focus = allFocused ? null : isFocused;\n\t\t\t\t_setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);\n\t\t\t});\n\n\t\t\tfocusedSeries = i;\n\t\t\t_setAlpha && commit();\n\t\t}\n\t}\n\n\tif (showLegend && cursorFocus) {\n\t\ton(mouseleave, legendEl, e => {\n\t\t\tif (cursor._lock)\n\t\t\t\treturn;\n\n\t\t\tif (focusedSeries != null)\n\t\t\t\tsetSeries(null, FOCUS_TRUE, true, syncOpts.setSeries);\n\t\t});\n\t}\n\n\tfunction posToVal(pos, scale, can) {\n\t\tlet sc = scales[scale];\n\n\t\tif (can)\n\t\t\tpos = pos / pxRatio - (sc.ori == 1 ? plotTopCss : plotLftCss);\n\n\t\tlet dim = plotWidCss;\n\n\t\tif (sc.ori == 1) {\n\t\t\tdim = plotHgtCss;\n\t\t\tpos = dim - pos;\n\t\t}\n\n\t\tif (sc.dir == -1)\n\t\t\tpos = dim - pos;\n\n\t\tlet _min = sc._min,\n\t\t\t_max = sc._max,\n\t\t\tpct = pos / dim;\n\n\t\tlet sv = _min + (_max - _min) * pct;\n\n\t\tlet distr = sc.distr;\n\n\t\treturn (\n\t\t\tdistr == 3 ? pow(10, sv) :\n\t\t\tdistr == 4 ? sinh(sv, sc.asinh) :\n\t\t\tsv\n\t\t);\n\t}\n\n\tfunction closestIdxFromXpos(pos, can) {\n\t\tlet v = posToVal(pos, xScaleKey, can);\n\t\treturn closestIdx(v, data[0], i0, i1);\n\t}\n\n\tself.valToIdx = val => closestIdx(val, data[0]);\n\tself.posToIdx = closestIdxFromXpos;\n\tself.posToVal = posToVal;\n\tself.valToPos = (val, scale, can) => (\n\t\tscales[scale].ori == 0 ?\n\t\tgetHPos(val, scales[scale],\n\t\t\tcan ? plotWid : plotWidCss,\n\t\t\tcan ? plotLft : 0,\n\t\t) :\n\t\tgetVPos(val, scales[scale],\n\t\t\tcan ? plotHgt : plotHgtCss,\n\t\t\tcan ? plotTop : 0,\n\t\t)\n\t);\n\n\t// defers calling expensive functions\n\tfunction batch(fn) {\n\t\tfn(self);\n\t\tcommit();\n\t}\n\n\tself.batch = batch;\n\n\t(self.setCursor = (opts, _fire, _pub) => {\n\t\tmouseLeft1 = opts.left;\n\t\tmouseTop1 = opts.top;\n\t//\tassign(cursor, opts);\n\t\tupdateCursor(null, _fire, _pub);\n\t});\n\n\tfunction setSelH(off, dim) {\n\t\tsetStylePx(selectDiv, LEFT,  select.left = off);\n\t\tsetStylePx(selectDiv, WIDTH, select.width = dim);\n\t}\n\n\tfunction setSelV(off, dim) {\n\t\tsetStylePx(selectDiv, TOP,    select.top = off);\n\t\tsetStylePx(selectDiv, HEIGHT, select.height = dim);\n\t}\n\n\tlet setSelX = scaleX.ori == 0 ? setSelH : setSelV;\n\tlet setSelY = scaleX.ori == 1 ? setSelH : setSelV;\n\n\tfunction syncLegend() {\n\t\tif (showLegend && legend.live) {\n\t\t\tfor (let i = mode == 2 ? 1 : 0; i < series.length; i++) {\n\t\t\t\tif (i == 0 && multiValLegend)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet vals = legend.values[i];\n\n\t\t\t\tlet j = 0;\n\n\t\t\t\tfor (let k in vals)\n\t\t\t\t\tlegendCells[i][j++].firstChild.nodeValue = vals[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setLegend(opts, _fire) {\n\t\tif (opts != null) {\n\t\t\tlet idx = opts.idx;\n\n\t\t\tlegend.idx = idx;\n\t\t\tseries.forEach((s, sidx) => {\n\t\t\t\t(sidx > 0 || !multiValLegend) && setLegendValues(sidx, idx);\n\t\t\t});\n\t\t}\n\n\t\tif (showLegend && legend.live)\n\t\t\tsyncLegend();\n\n\t\tshouldSetLegend = false;\n\n\t\t_fire !== false && fire(\"setLegend\");\n\t}\n\n\tself.setLegend = setLegend;\n\n\tfunction setLegendValues(sidx, idx) {\n\t\tlet val;\n\n\t\tif (idx == null)\n\t\t\tval = NULL_LEGEND_VALUES;\n\t\telse {\n\t\t\tlet s = series[sidx];\n\t\t\tlet src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];\n\t\t\tval = multiValLegend ? s.values(self, sidx, idx) : {_: s.value(self, src[idx], sidx, idx)};\n\t\t}\n\n\t\tlegend.values[sidx] = val;\n\t}\n\n\tfunction updateCursor(src, _fire, _pub) {\n\t//\tts == null && log(\"updateCursor()\", arguments);\n\n\t\trawMouseLeft1 = mouseLeft1;\n\t\trawMouseTop1 = mouseTop1;\n\n\t\t[mouseLeft1, mouseTop1] = cursor.move(self, mouseLeft1, mouseTop1);\n\n\t\tif (cursor.show) {\n\t\t\tvCursor && elTrans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);\n\t\t\thCursor && elTrans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);\n\t\t}\n\n\t\tlet idx;\n\n\t\t// when zooming to an x scale range between datapoints the binary search\n\t\t// for nearest min/max indices results in this condition. cheap hack :D\n\t\tlet noDataInRange = i0 > i1; // works for mode 1 only\n\n\t\tclosestDist = inf;\n\n\t\t// TODO: extract\n\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;\n\t\tlet yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;\n\n\t\t// if cursor hidden, hide points & clear legend vals\n\t\tif (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {\n\t\t\tidx = null;\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cursorFocus)\n\t\t\t\tsetSeries(null, FOCUS_TRUE, true, src == null && syncOpts.setSeries);\n\n\t\t\tif (legend.live) {\n\t\t\t\tactiveIdxs.fill(null);\n\t\t\t\tshouldSetLegend = true;\n\n\t\t\t\tfor (let i = 0; i < series.length; i++)\n\t\t\t\t\tlegend.values[i] = NULL_LEGEND_VALUES;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t//\tlet pctY = 1 - (y / rect.height);\n\n\t\t\tlet mouseXPos, valAtPosX, xPos;\n\n\t\t\tif (mode == 1) {\n\t\t\t\tmouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;\n\t\t\t\tvalAtPosX = posToVal(mouseXPos, xScaleKey);\n\t\t\t\tidx = closestIdx(valAtPosX, data[0], i0, i1);\n\t\t\t\txPos = incrRoundUp(valToPosX(data[0][idx], scaleX, xDim, 0), 0.5);\n\t\t\t}\n\n\t\t\tfor (let i = mode == 2 ? 1 : 0; i < series.length; i++) {\n\t\t\t\tlet s = series[i];\n\n\t\t\t\tlet idx1  = activeIdxs[i];\n\t\t\t\tlet yVal1 = mode == 1 ? data[i][idx1] : data[i][1][idx1];\n\n\t\t\t\tlet idx2  = cursor.dataIdx(self, i, idx, valAtPosX);\n\t\t\t\tlet yVal2 = mode == 1 ? data[i][idx2] : data[i][1][idx2];\n\n\t\t\t\tshouldSetLegend = shouldSetLegend || yVal2 != yVal1 || idx2 != idx1;\n\n\t\t\t\tactiveIdxs[i] = idx2;\n\n\t\t\t\tlet xPos2 = idx2 == idx ? xPos : incrRoundUp(valToPosX(mode == 1 ? data[0][idx2] : data[i][0][idx2], scaleX, xDim, 0), 0.5);\n\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tlet yPos = yVal2 == null ? -10 : incrRoundUp(valToPosY(yVal2, mode == 1 ? scales[s.scale] : scales[s.facets[1].scale], yDim, 0), 0.5);\n\n\t\t\t\t\tif (yPos > 0 && mode == 1) {\n\t\t\t\t\t\tlet dist = abs(yPos - mouseTop1);\n\n\t\t\t\t\t\tif (dist <= closestDist) {\n\t\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\tclosestSeries = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet hPos, vPos;\n\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\thPos = xPos2;\n\t\t\t\t\t\tvPos = yPos;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thPos = yPos;\n\t\t\t\t\t\tvPos = xPos2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shouldSetLegend && cursorPts.length > 1) {\n\t\t\t\t\t\telColor(cursorPts[i], cursor.points.fill(self, i), cursor.points.stroke(self, i));\n\n\t\t\t\t\t\tlet ptWid, ptHgt, ptLft, ptTop,\n\t\t\t\t\t\t\tcentered = true,\n\t\t\t\t\t\t\tgetBBox = cursor.points.bbox;\n\n\t\t\t\t\t\tif (getBBox != null) {\n\t\t\t\t\t\t\tcentered = false;\n\n\t\t\t\t\t\t\tlet bbox = getBBox(self, i);\n\n\t\t\t\t\t\t\tptLft = bbox.left;\n\t\t\t\t\t\t\tptTop = bbox.top;\n\t\t\t\t\t\t\tptWid = bbox.width;\n\t\t\t\t\t\t\tptHgt = bbox.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tptLft = hPos;\n\t\t\t\t\t\t\tptTop = vPos;\n\t\t\t\t\t\t\tptWid = ptHgt = cursor.points.size(self, i);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telSize(cursorPts[i], ptWid, ptHgt, centered);\n\t\t\t\t\t\telTrans(cursorPts[i], ptLft, ptTop, plotWidCss, plotHgtCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (legend.live) {\n\t\t\t\t\tif (!shouldSetLegend || i == 0 && multiValLegend)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsetLegendValues(i, idx2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcursor.idx = idx;\n\t\tcursor.left = mouseLeft1;\n\t\tcursor.top = mouseTop1;\n\n\t\tif (shouldSetLegend) {\n\t\t\tlegend.idx = idx;\n\t\t\tsetLegend();\n\t\t}\n\n\t\t// nit: cursor.drag.setSelect is assumed always true\n\t\tif (select.show && dragging) {\n\t\t\tif (src != null) {\n\t\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\t\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\t\t\t\tlet [xKeySrc, yKeySrc] = src.cursor.sync.scales;\n\n\t\t\t\t// match the dragX/dragY implicitness/explicitness of src\n\t\t\t\tlet sdrag = src.cursor.drag;\n\t\t\t\tdragX = sdrag._x;\n\t\t\t\tdragY = sdrag._y;\n\n\t\t\t\tif (dragX || dragY) {\n\t\t\t\t\tlet { left, top, width, height } = src.select;\n\n\t\t\t\t\tlet sori = src.scales[xKey].ori;\n\t\t\t\t\tlet sPosToVal = src.posToVal;\n\n\t\t\t\t\tlet sOff, sDim, sc, a, b;\n\n\t\t\t\t\tlet matchingX = xKey != null && matchXKeys(xKey, xKeySrc);\n\t\t\t\t\tlet matchingY = yKey != null && matchYKeys(yKey, yKeySrc);\n\n\t\t\t\t\tif (matchingX && dragX) {\n\t\t\t\t\t\tif (sori == 0) {\n\t\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsc = scales[xKey];\n\n\t\t\t\t\t\ta = valToPosX(sPosToVal(sOff, xKeySrc),        sc, xDim, 0);\n\t\t\t\t\t\tb = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);\n\n\t\t\t\t\t\tsetSelX(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelX(0, xDim);\n\n\t\t\t\t\tif (matchingY && dragY) {\n\t\t\t\t\t\tif (sori == 1) {\n\t\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsc = scales[yKey];\n\n\t\t\t\t\t\ta = valToPosY(sPosToVal(sOff, yKeySrc),        sc, yDim, 0);\n\t\t\t\t\t\tb = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);\n\n\t\t\t\t\t\tsetSelY(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thideSelect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet rawDX = abs(rawMouseLeft1 - rawMouseLeft0);\n\t\t\t\tlet rawDY = abs(rawMouseTop1 - rawMouseTop0);\n\n\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\tlet _rawDX = rawDX;\n\t\t\t\t\trawDX = rawDY;\n\t\t\t\t\trawDY = _rawDX;\n\t\t\t\t}\n\n\t\t\t\tdragX = drag.x && rawDX >= drag.dist;\n\t\t\t\tdragY = drag.y && rawDY >= drag.dist;\n\n\t\t\t\tlet uni = drag.uni;\n\n\t\t\t\tif (uni != null) {\n\t\t\t\t\t// only calc drag status if they pass the dist thresh\n\t\t\t\t\tif (dragX && dragY) {\n\t\t\t\t\t\tdragX = rawDX >= uni;\n\t\t\t\t\t\tdragY = rawDY >= uni;\n\n\t\t\t\t\t\t// force unidirectionality when both are under uni limit\n\t\t\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\t\t\tif (rawDY > rawDX)\n\t\t\t\t\t\t\t\tdragY = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdragX = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (drag.x && drag.y && (dragX || dragY))\n\t\t\t\t\t// if omni with no uni then both dragX / dragY should be true if either is true\n\t\t\t\t\tdragX = dragY = true;\n\n\t\t\t\tlet p0, p1;\n\n\t\t\t\tif (dragX) {\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelX(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragY)\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\n\t\t\t\tif (dragY) {\n\t\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelY(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragX)\n\t\t\t\t\t\tsetSelX(0, xDim);\n\t\t\t\t}\n\n\t\t\t\t// the drag didn't pass the dist requirement\n\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\tsetSelX(0, 0);\n\t\t\t\t\tsetSelY(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrag._x = dragX;\n\t\tdrag._y = dragY;\n\n\t\tif (src == null) {\n\t\t\tif (_pub) {\n\t\t\t\tif (syncKey != null) {\n\t\t\t\t\tlet [xSyncKey, ySyncKey] = syncOpts.scales;\n\n\t\t\t\t\tsyncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;\n\t\t\t\t\tsyncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;\n\t\t\t\t}\n\n\t\t\t\tpubSync(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);\n\t\t\t}\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tlet shouldPub = _pub && syncOpts.setSeries;\n\t\t\t\tlet p = focus.prox;\n\n\t\t\t\tif (focusedSeries == null) {\n\t\t\t\t\tif (closestDist <= p)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (closestDist > p)\n\t\t\t\t\t\tsetSeries(null, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t\telse if (closestSeries != focusedSeries)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tready && _fire !== false && fire(\"setCursor\");\n\t}\n\n\tlet rect = null;\n\n\tfunction syncRect(defer) {\n\t\tif (defer === true)\n\t\t\trect = null;\n\t\telse {\n\t\t\trect = over.getBoundingClientRect();\n\t\t\tfire(\"syncRect\", rect);\n\t\t}\n\t}\n\n\tfunction mouseMove(e, src, _l, _t, _w, _h, _i) {\n\t\tif (cursor._lock)\n\t\t\treturn;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);\n\n\t\tif (e != null)\n\t\t\tupdateCursor(null, true, true);\n\t\telse\n\t\t\tupdateCursor(src, true, false);\n\t}\n\n\tfunction cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {\n\t\tif (rect == null)\n\t\t\tsyncRect(false);\n\n\t\tif (e != null) {\n\t\t\t_l = e.clientX - rect.left;\n\t\t\t_t = e.clientY - rect.top;\n\t\t}\n\t\telse {\n\t\t\tif (_l < 0 || _t < 0) {\n\t\t\t\tmouseLeft1 = -10;\n\t\t\t\tmouseTop1 = -10;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\n\t\t\tlet syncOptsSrc = src.cursor.sync;\n\t\t\tlet [xValSrc, yValSrc] = syncOptsSrc.values;\n\t\t\tlet [xKeySrc, yKeySrc] = syncOptsSrc.scales;\n\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\n\t\t\tlet rotSrc = src.axes[0].side % 2 == 1;\n\n\t\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss,\n\t\t\t\tyDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss,\n\t\t\t\t_xDim = rotSrc ? _h : _w,\n\t\t\t\t_yDim = rotSrc ? _w : _h,\n\t\t\t\t_xPos = rotSrc ? _t : _l,\n\t\t\t\t_yPos = rotSrc ? _l : _t;\n\n\t\t\tif (xKeySrc != null)\n\t\t\t\t_l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_l = xDim * (_xPos/_xDim);\n\n\t\t\tif (yKeySrc != null)\n\t\t\t\t_t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_t = yDim * (_yPos/_yDim);\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\tlet __l = _l;\n\t\t\t\t_l = _t;\n\t\t\t\t_t = __l;\n\t\t\t}\n\t\t}\n\n\t\tif (snap) {\n\t\t\tif (_l <= 1 || _l >= plotWidCss - 1)\n\t\t\t\t_l = incrRound(_l, plotWidCss);\n\n\t\t\tif (_t <= 1 || _t >= plotHgtCss - 1)\n\t\t\t\t_t = incrRound(_t, plotHgtCss);\n\t\t}\n\n\t\tif (initial) {\n\t\t\trawMouseLeft0 = _l;\n\t\t\trawMouseTop0 = _t;\n\n\t\t\t[mouseLeft0, mouseTop0] = cursor.move(self, _l, _t);\n\t\t}\n\t\telse {\n\t\t\tmouseLeft1 = _l;\n\t\t\tmouseTop1 = _t;\n\t\t}\n\t}\n\n\tconst _hideProps = {\n\t\twidth: 0,\n\t\theight: 0,\n\t};\n\n\tfunction hideSelect() {\n\t\tsetSelect(_hideProps, false);\n\t}\n\n\tfunction mouseDown(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = true;\n\t\tdragX = dragY = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, true, false);\n\n\t\tif (e != null) {\n\t\t\tonMouse(mouseup, doc, mouseUp);\n\t\t\tpubSync(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseUp(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, true);\n\n\t\tlet { left, top, width, height } = select;\n\n\t\tlet hasSelect = width > 0 || height > 0;\n\n\t\thasSelect && setSelect(select);\n\n\t\tif (drag.setScale && hasSelect) {\n\t\t//\tif (syncKey != null) {\n\t\t//\t\tdragX = drag.x;\n\t\t//\t\tdragY = drag.y;\n\t\t//\t}\n\n\t\t\tlet xOff = left,\n\t\t\t\txDim = width,\n\t\t\t\tyOff = top,\n\t\t\t\tyDim = height;\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\txOff = top,\n\t\t\t\txDim = height,\n\t\t\t\tyOff = left,\n\t\t\t\tyDim = width;\n\t\t\t}\n\n\t\t\tif (dragX) {\n\t\t\t\t_setScale(xScaleKey,\n\t\t\t\t\tposToVal(xOff, xScaleKey),\n\t\t\t\t\tposToVal(xOff + xDim, xScaleKey)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (dragY) {\n\t\t\t\tfor (let k in scales) {\n\t\t\t\t\tlet sc = scales[k];\n\n\t\t\t\t\tif (k != xScaleKey && sc.from == null && sc.min != inf) {\n\t\t\t\t\t\t_setScale(k,\n\t\t\t\t\t\t\tposToVal(yOff + yDim, k),\n\t\t\t\t\t\t\tposToVal(yOff, k)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thideSelect();\n\t\t}\n\t\telse if (cursor.lock) {\n\t\t\tcursor._lock = !cursor._lock;\n\n\t\t\tif (!cursor._lock)\n\t\t\t\tupdateCursor(null, true, false);\n\t\t}\n\n\t\tif (e != null) {\n\t\t\toffMouse(mouseup, doc);\n\t\t\tpubSync(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseLeave(e, src, _l, _t, _w, _h, _i) {\n\t\tif (!cursor._lock) {\n\t\t\tlet _dragging = dragging;\n\n\t\t\tif (dragging) {\n\t\t\t\t// handle case when mousemove aren't fired all the way to edges by browser\n\t\t\t\tlet snapH = true;\n\t\t\t\tlet snapV = true;\n\t\t\t\tlet snapProx = 10;\n\n\t\t\t\tlet dragH, dragV;\n\n\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\tdragH = dragX;\n\t\t\t\t\tdragV = dragY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdragH = dragY;\n\t\t\t\t\tdragV = dragX;\n\t\t\t\t}\n\n\t\t\t\tif (dragH && dragV) {\n\t\t\t\t\t// maybe omni corner snap\n\t\t\t\t\tsnapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;\n\t\t\t\t\tsnapV = mouseTop1  <= snapProx || mouseTop1  >= plotHgtCss - snapProx;\n\t\t\t\t}\n\n\t\t\t\tif (dragH && snapH)\n\t\t\t\t\tmouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;\n\n\t\t\t\tif (dragV && snapV)\n\t\t\t\t\tmouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;\n\n\t\t\t\tupdateCursor(null, true, true);\n\n\t\t\t\tdragging = false;\n\t\t\t}\n\n\t\t\tmouseLeft1 = -10;\n\t\t\tmouseTop1 = -10;\n\n\t\t\t// passing a non-null timestamp to force sync/mousemove event\n\t\t\tupdateCursor(null, true, true);\n\n\t\t\tif (_dragging)\n\t\t\t\tdragging = _dragging;\n\t\t}\n\t}\n\n\tfunction dblClick(e, src, _l, _t, _w, _h, _i) {\n\t\tautoScaleX();\n\n\t\thideSelect();\n\n\t\tif (e != null)\n\t\t\tpubSync(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t}\n\n\tfunction syncPxRatio() {\n\t\taxes.forEach(syncFontSize);\n\t\t_setSize(self.width, self.height, true);\n\t}\n\n\ton(dppxchange, win, syncPxRatio);\n\n\t// internal pub/sub\n\tconst events = {};\n\n\tevents.mousedown = mouseDown;\n\tevents.mousemove = mouseMove;\n\tevents.mouseup = mouseUp;\n\tevents.dblclick = dblClick;\n\tevents[\"setSeries\"] = (e, src, idx, opts) => {\n\t\tsetSeries(idx, opts, true, false);\n\t};\n\n\tif (cursor.show) {\n\t\tonMouse(mousedown,  over, mouseDown);\n\t\tonMouse(mousemove,  over, mouseMove);\n\t\tonMouse(mouseenter, over, syncRect);\n\t\tonMouse(mouseleave, over, mouseLeave);\n\n\t\tonMouse(dblclick, over, dblClick);\n\n\t\tcursorPlots.add(self);\n\n\t\tself.syncRect = syncRect;\n\t}\n\n\t// external on/off\n\tconst hooks = self.hooks = opts.hooks || {};\n\n\tfunction fire(evName, a1, a2) {\n\t\tif (evName in hooks) {\n\t\t\thooks[evName].forEach(fn => {\n\t\t\t\tfn.call(null, self, a1, a2);\n\t\t\t});\n\t\t}\n\t}\n\n\t(opts.plugins || []).forEach(p => {\n\t\tfor (let evName in p.hooks)\n\t\t\thooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);\n\t});\n\n\tconst syncOpts = assign({\n\t\tkey: null,\n\t\tsetSeries: false,\n\t\tfilters: {\n\t\t\tpub: retTrue,\n\t\t\tsub: retTrue,\n\t\t},\n\t\tscales: [xScaleKey, series[1] ? series[1].scale : null],\n\t\tmatch: [retEq, retEq],\n\t\tvalues: [null, null],\n\t}, cursor.sync);\n\n\t(cursor.sync = syncOpts);\n\n\tconst syncKey = syncOpts.key;\n\n\tconst sync = _sync(syncKey);\n\n\tfunction pubSync(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.pub(type, src, x, y, w, h, i))\n\t\t\tsync.pub(type, src, x, y, w, h, i);\n\t}\n\n\tsync.sub(self);\n\n\tfunction pub(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.sub(type, src, x, y, w, h, i))\n\t\t\tevents[type](null, src, x, y, w, h, i);\n\t}\n\n\t(self.pub = pub);\n\n\tfunction destroy() {\n\t\tsync.unsub(self);\n\t\tcursorPlots.delete(self);\n\t\tmouseListeners.clear();\n\t\toff(dppxchange, win, syncPxRatio);\n\t\troot.remove();\n\t\tfire(\"destroy\");\n\t}\n\n\tself.destroy = destroy;\n\n\tfunction _init() {\n\t\tfire(\"init\", opts, data);\n\n\t\tsetData(data || opts.data, false);\n\n\t\tif (pendScales[xScaleKey])\n\t\t\tsetScale(xScaleKey, pendScales[xScaleKey]);\n\t\telse\n\t\t\tautoScaleX();\n\n\t\t_setSize(opts.width, opts.height);\n\n\t\tupdateCursor(null, true, false);\n\n\t\tsetSelect(select, false);\n\t}\n\n\tseries.forEach(initSeries);\n\n\taxes.forEach(initAxis);\n\n\tif (then) {\n\t\tif (then instanceof HTMLElement) {\n\t\t\tthen.appendChild(root);\n\t\t\t_init();\n\t\t}\n\t\telse\n\t\t\tthen(self, _init);\n\t}\n\telse\n\t\t_init();\n\n\treturn self;\n}\n\nuPlot.assign = assign;\nuPlot.fmtNum = fmtNum;\nuPlot.rangeNum = rangeNum;\nuPlot.rangeLog = rangeLog;\nuPlot.rangeAsinh = rangeAsinh;\nuPlot.orient   = orient;\nuPlot.pxRatio = pxRatio;\n\n{\n\tuPlot.join = join;\n}\n\n{\n\tuPlot.fmtDate = fmtDate;\n\tuPlot.tzDate  = tzDate;\n}\n\n{\n\tuPlot.sync = _sync;\n}\n\n{\n\tuPlot.addGap = addGap;\n\tuPlot.clipGaps = clipGaps;\n\n\tlet paths = uPlot.paths = {\n\t\tpoints,\n\t};\n\n\t(paths.linear  = linear);\n\t(paths.stepped = stepped);\n\t(paths.bars    = bars);\n\t(paths.spline  = monotoneCubic);\n}\n\nexport { uPlot as default };\n", "import { LineColor } from './color_wheel'\nimport uPlot from 'uplot'\n\nconst histBucket = (v, offset, incr) => incrRoundDn(v - offset, incr) + offset\nconst histSort = (a, b) => a - b\n\nfunction incrRoundDn(num, incr) {\n  return Math.floor(num / incr) * incr\n}\n\nfunction reBin(histogram, sort) {\n  let bins = [...histogram.values()]\n\n  sort && bins.sort((a, b) => sort(a.value, b.value))\n\n  let values = Array(bins.length)\n  let counts = Array(bins.length)\n\n  for (let i = 0; i < bins.length; i++) {\n    values[i] = bins[i].value\n    counts[i] = bins[i].count\n  }\n\n  return [values, counts]\n}\n\nconst getBucketSize = ({ bucketSize = 20 }) => +bucketSize\n\nexport class Histogram {\n  constructor(chart, options) {\n    this.chart = chart\n    this.datasets = new Map();\n    this.options = options\n    this.bucketSize = getBucketSize(options)\n    this.histOffset = 0\n    // todo: enable pruning for histogram?\n  }\n\n  handleMeasurements(data) {\n    data.forEach(({ y }) => {\n      if (y == null) { return }\n      y = histBucket(y, this.histOffset, this.bucketSize)\n\n      let entry = this.datasets.get(y)\n\n      if (entry) {\n        entry.count++\n      } else {\n        this.datasets.set(y, { value: y, count: 1 })\n      }\n    })\n\n    this.chart.setData(reBin(this.datasets, histSort))\n  }\n\n  static initialData() { return [[], []] }\n\n  static getConfig(options) {\n    let bucketIncr = getBucketSize(options)\n    let bars = uPlot.paths.bars({ align: 1, size: [1, Infinity], gap: 4 })\n\n    return {\n      title: options.title,\n      width: options.width,\n      height: options.height,\n      scales: {\n        x: {\n          time: false,\n          auto: false,\n          dir: 1,\n          range: (u) => [\n            u.data[0][0],\n            u.data[0][u.data[0].length - 1] + bucketIncr,\n          ]\n        }\n      },\n      axes: [\n        {\n          incrs: () => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(mult => mult * bucketIncr),\n          //\tspace: 0,\n          splits: (u, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n            let minSpace = u.axes[axisIdx]._space\n            let bucketWidth = u.valToPos(u.data[0][0] + bucketIncr, 'x') - u.valToPos(u.data[0][0], 'x')\n\n            let firstSplit = u.data[0][0]\n            let lastSplit = u.data[0][u.data[0].length - 1] + bucketIncr\n\n            let splits = []\n            let skip = Math.ceil(minSpace / bucketWidth)\n\n            for (let i = 0, s = firstSplit; s <= lastSplit; i++, s += bucketIncr)\n              !(i % skip) && splits.push(s)\n\n            return splits\n          }\n        }\n      ],\n      series: [\n        {\n          label: options.label,\n          value: (self, rawValue) => rawValue + `-${rawValue + bucketIncr} ${options.unit}`,\n        },\n        {\n          paths: bars,\n          points: { show: false },\n          ...LineColor.at(1),\n          width: 2,\n          label: \"Events\"\n        },\n      ],\n    }\n  }\n}", "import { LineColor } from './color_wheel'\nimport { Histogram } from './histogram.js'\nimport uPlot from 'uplot'\n\nconst SeriesValue = (options) => {\n  if (!options.unit) return {}\n\n  return {\n    value: (u, v) => v == null ? '--' : v.toFixed(3) + ` ${options.unit}`\n  }\n}\n\nconst XSeriesValue = (options) => {\n  return {\n    value: '{YYYY}-{MM}-{DD} {HH}:{mm}:{ss}'\n  }\n}\n\nconst YAxisValue = (options) => {\n  if (!options.unit) return {}\n\n  return {\n    values: (u, vals, space) => vals.map(v => +v.toFixed(2) + ` ${options.unit}`)\n  }\n}\n\nconst XAxis = (_options) => {\n  return {\n    space: 55,\n    // [0]:   minimum num secs in found axis split (tick incr)\n    // [1]:   default tick format\n    // [2-7]: rollover tick formats\n    // [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]\n    values: [\n      // tick incr          default           year                             month    day                        hour     min                sec       mode\n      [3600 * 24 * 365,   \"{YYYY}\",         null,                            null,    null,                      null,    null,              null,        1],\n      [3600 * 24 * 28,    \"{MMM}\",          \"\\n{YYYY}\",                      null,    null,                      null,    null,              null,        1],\n      [3600 * 24,         \"{M}/{D}\",        \"\\n{YYYY}\",                      null,    null,                      null,    null,              null,        1],\n      [3600,              \"{h}{aa}\",        \"\\n{M}/{D}/{YY}\",                null,    \"\\n{M}/{D}\",               null,    null,              null,        1],\n      [60,                \"{h}:{mm}{aa}\",   \"\\n{M}/{D}/{YY}\",                null,    \"\\n{M}/{D}\",               null,    null,              null,        1],\n      [1,                 \":{ss}\",          \"\\n{M}/{D}/{YY} {h}:{mm}{aa}\",   null,    \"\\n{M}/{D} {h}:{mm}{aa}\",  null,    \"\\n{h}:{mm}{aa}\",  null,        1],\n      [0.001,             \":{ss}.{fff}\",    \"\\n{M}/{D}/{YY} {h}:{mm}{aa}\",   null,    \"\\n{M}/{D} {h}:{mm}{aa}\",  null,    \"\\n{h}:{mm}{aa}\",  null,        1],\n    ]\n  }\n}\n\nconst YAxis = (options) => {\n  return {\n    show: true,\n    size: 70,\n    space: 15,\n    ...YAxisValue(options)\n  }\n}\n\nconst minChartSize = {\n  width: 100,\n  height: 300\n}\n\nconst cursorOpts = {\n  sync: { key: 'metrics-live' }\n}\n\n// Limits how often a function is invoked\nfunction throttle(cb, limit) {\n  let wait = false;\n\n  return () => {\n    if (!wait) {\n      requestAnimationFrame(cb);\n      wait = true;\n      setTimeout(() => {\n        wait = false;\n      }, limit);\n    }\n  }\n}\n\nexport const newSeriesConfig = (options, index = 0) => {\n  return {\n    ...LineColor.at(index),\n    ...SeriesValue(options),\n    label: options.label,\n    spanGaps: true,\n    points: { show: false }\n  }\n}\n\n/** Telemetry Metrics **/\n\n// Maps an ordered list of dataset objects into an ordered list of data points.\nconst dataForDatasets = (datasets) => datasets.slice(0).map(({ data }) => data)\n\n// Handler for an untagged CommonMetric\nfunction nextValueForCallback({ y, z }, callback) {\n  this.datasets[0].data.push(z)\n  let currentValue = this.datasets[1].data[this.datasets[1].data.length - 1] || 0\n  let nextValue = callback.call(this, y, currentValue)\n  this.datasets[1].data.push(nextValue)\n}\n\nconst findLastNonNullValue = (data) => data.reduceRight((a, c) => (c != null && a == null ? c : a), null)\n\n// Handler for a tagged CommonMetric\nfunction nextTaggedValueForCallback({ x, y, z }, callback) {\n  // Find or create the series from the tag\n  let seriesIndex = this.datasets.findIndex(({ key }) => x === key)\n  if (seriesIndex === -1) {\n    seriesIndex = this.datasets.push({ key: x, data: Array(this.datasets[0].data.length).fill(null) }) - 1\n    this.chart.addSeries(newSeriesConfig({ label: x, unit: this.options.unit }, seriesIndex - 1), seriesIndex)\n  }\n\n  // Add the new timestamp + value, keeping datasets aligned\n  this.datasets = this.datasets.map((dataset, index) => {\n    if (index === 0) {\n      dataset.data.push(z)\n    } else if (index === seriesIndex) {\n      dataset.data.push(callback.call(this, y, findLastNonNullValue(dataset.data) || 0))\n    } else {\n      dataset.data.push(null)\n    }\n    return dataset\n  })\n}\n\nconst getPruneThreshold = ({ pruneThreshold = 1000 }) => pruneThreshold\n\n// Handles the basic metrics like Counter, LastValue, and Sum.\nclass CommonMetric {\n  static __projections() {\n    return {\n      counter: (y, value) => value + 1,\n      last_value: (y) => y,\n      sum: (y, value) => value + y\n    }\n  }\n\n  static getConfig(options) {\n    return {\n      class: options.kind,\n      title: options.title,\n      width: options.width,\n      height: options.height,\n      cursor: cursorOpts,\n      series: [\n        { ...XSeriesValue() },\n        newSeriesConfig(options, 0)\n      ],\n      scales: {\n        x: {\n          min: options.now - 60,\n          max: options.now\n        },\n        y: {\n          min: 0,\n          max: 1\n        },\n      },\n      axes: [\n        XAxis(),\n        YAxis(options)\n      ]\n    }\n  }\n\n  static initialData() {\n    return [[], []]\n  }\n\n  constructor(chart, options) {\n    this.__callback = this.constructor.__projections()[options.metric]\n    this.chart = chart\n    this.datasets = [{ key: \"|x|\", data: [] }]\n    this.options = options\n    this.pruneThreshold = getPruneThreshold(options)\n\n    if (options.tagged) {\n      this.chart.delSeries(1)\n      this.__handler = nextTaggedValueForCallback\n    } else {\n      this.datasets.push({ key: options.label, data: [] })\n      this.__handler = nextValueForCallback\n    }\n  }\n\n  handleMeasurements(measurements) {\n    // prune datasets when we reach the max number of events\n    measurements.forEach((measurement) => this.__handler.call(this, measurement, this.__callback))\n\n    let currentSize = this.datasets[0].data.length\n    if (currentSize >= this.pruneThreshold) {\n      this.datasets = this.datasets.map(({ data, ...rest }) => {\n        return { data: data.slice(-this.pruneThreshold), ...rest }\n      })\n    }\n\n    this.chart.setData(dataForDatasets(this.datasets))\n  }\n}\n\n// Displays a measurement summary\nclass Summary {\n  constructor(options, chartEl) {\n    // TODO: Get percentiles from options\n    let config = this.constructor.getConfig(options)\n    // Bind the series `values` callback to this instance\n    config.series[1].values = this.__seriesValues.bind(this)\n\n    this.datasets = [{ key: \"|x|\", data: [] }]\n    this.chart = new uPlot(config, this.constructor.initialData(options), chartEl)\n    this.pruneThreshold = getPruneThreshold(options)\n    this.options = options\n\n    if (options.tagged) {\n      this.chart.delSeries(1)\n      this.__handler = this.handleTaggedMeasurement.bind(this)\n    } else {\n      this.datasets.push(this.constructor.newDataset(options.label))\n      this.__handler = this.handleMeasurement.bind(this)\n    }\n  }\n\n  handleMeasurements(measurements) {\n    measurements.forEach((measurement) => this.__handler(measurement))\n    this.__maybePruneDatasets()\n    this.chart.setData(dataForDatasets(this.datasets))\n  }\n\n  handleTaggedMeasurement(measurement) {\n    let seriesIndex = this.findOrCreateSeries(measurement.x)\n    this.handleMeasurement(measurement, seriesIndex)\n  }\n\n  handleMeasurement(measurement, sidx = 1) {\n    let { z: timestamp } = measurement\n    this.datasets = this.datasets.map((dataset, index) => {\n      if (dataset.key === \"|x|\") {\n        dataset.data.push(timestamp)\n      } else if (index === sidx) {\n        this.pushToDataset(dataset, measurement)\n      } else {\n        this.pushToDataset(dataset, null)\n      }\n      return dataset\n    })\n  }\n\n  findOrCreateSeries(label) {\n    let seriesIndex = this.datasets.findIndex(({ key }) => label === key)\n    if (seriesIndex === -1) {\n      seriesIndex = this.datasets.push(\n        this.constructor.newDataset(label, this.datasets[0].data.length)\n      ) - 1\n\n      let config = {\n        values: this.__seriesValues.bind(this),\n        ...newSeriesConfig({ label }, seriesIndex - 1)\n      }\n\n      this.chart.addSeries(config, seriesIndex)\n    }\n\n    return seriesIndex\n  }\n\n  pushToDataset(dataset, measurement) {\n    if (measurement === null) {\n      dataset.data.push(null)\n      dataset.agg.avg.push(null)\n      dataset.agg.max.push(null)\n      dataset.agg.min.push(null)\n      return\n    }\n\n    let { y } = measurement\n\n    // Increment the new overall totals\n    dataset.agg.count++\n    dataset.agg.total += y\n\n    // Push the value\n    dataset.data.push(y)\n\n    // Push min/max/avg\n    if (dataset.last.min === null || y < dataset.last.min) { dataset.last.min = y }\n    dataset.agg.min.push(dataset.last.min)\n\n    if (dataset.last.max === null || y > dataset.last.max) { dataset.last.max = y }\n    dataset.agg.max.push(dataset.last.max)\n\n    dataset.agg.avg.push((dataset.agg.total / dataset.agg.count))\n\n    return dataset\n  }\n\n  __maybePruneDatasets() {\n    let currentSize = this.datasets[0].data.length\n    if (currentSize > this.pruneThreshold) {\n      let start = -this.pruneThreshold;\n      this.datasets = this.datasets.map(({ key, data, agg }) => {\n        let dataPruned = data.slice(start)\n        if (!agg) {\n          return { key, data: dataPruned }\n        }\n\n        let { avg, count, max, min, total } = agg\n        let minPruned = min.slice(start)\n        let maxPruned = max.slice(start)\n\n        return {\n          key,\n          data: dataPruned,\n          agg: {\n            avg: avg.slice(start),\n            count,\n            min: minPruned,\n            max: maxPruned,\n            total\n          },\n          last: {\n            min: findLastNonNullValue(minPruned),\n            max: findLastNonNullValue(maxPruned)\n          }\n        }\n      })\n    }\n  }\n\n  __seriesValues(u, sidx, idx) {\n    let dataset = this.datasets[sidx]\n    if (dataset && dataset.data && dataset.data[idx]) {\n      let { agg: { avg, max, min }, data } = dataset\n      return {\n        Value: data[idx].toFixed(3),\n        Min: min[idx].toFixed(3),\n        Max: max[idx].toFixed(3),\n        Avg: avg[idx].toFixed(3)\n      }\n    } else {\n      return { Value: \"--\", Min: \"--\", Max: \"--\", Avg: \"--\" }\n    }\n  }\n\n  static initialData() { return [[], []] }\n\n  static getConfig(options) {\n    return {\n      class: options.kind,\n      title: options.title,\n      width: options.width,\n      height: options.height,\n      cursor: cursorOpts,\n      series: [\n        { ...XSeriesValue() },\n        newSeriesConfig(options, 0)\n      ],\n      scales: {\n        x: {\n          min: options.now - 60,\n          max: options.now\n        },\n        y: {\n          min: 0,\n          max: 1\n        },\n      },\n      axes: [\n        XAxis(),\n        YAxis(options)\n      ]\n    }\n  }\n\n  static newDataset(key, length = 0) {\n    let nils = length > 0 ? Array(length).fill(null) : []\n    return {\n      key,\n      data: [...nils],\n      agg: { avg: [...nils], count: 0, max: [...nils], min: [...nils], total: 0 },\n      last: { max: null, min: null }\n    }\n  }\n}\n\nconst __METRICS__ = {\n  counter: CommonMetric,\n  last_value: CommonMetric,\n  sum: CommonMetric,\n  summary: Summary,\n  distribution: Histogram\n}\n\nexport class TelemetryChart {\n  constructor(chartEl, options) {\n    if (!options.metric) {\n      throw new TypeError(`No metric type was provided`)\n    } else if (options.metric && !__METRICS__[options.metric]) {\n      throw new TypeError(`No metric defined for type ${options.metric}`)\n    }\n\n    const metric = __METRICS__[options.metric]\n    if (metric === Summary) {\n      this.metric = new Summary(options, chartEl)\n      this.uplotChart = this.metric.chart\n    } else {\n      this.uplotChart = new uPlot(metric.getConfig(options), metric.initialData(options), chartEl)\n      this.metric = new metric(this.uplotChart, options)\n    }\n\n    // setup the data buffer\n    let isBufferingData = typeof options.refreshInterval !== \"undefined\"\n    this._isBufferingData = isBufferingData\n    this._buffer = []\n    this._timer = isBufferingData ? setInterval(\n      this._flushToChart.bind(this),\n      +options.refreshInterval\n    ) : null\n  }\n\n  clearTimers() { clearInterval(this._timer) }\n\n  resize(boundingBox) {\n    this.uplotChart.setSize({\n      width: Math.max(boundingBox.width, minChartSize.width),\n      height: minChartSize.height\n    })\n  }\n\n  pushData(measurements) {\n    if (!measurements.length) return\n    let callback = this._isBufferingData ? this._pushToBuffer : this._pushToChart\n    callback.call(this, measurements)\n  }\n\n  _pushToBuffer(measurements) {\n    this._buffer = this._buffer.concat(measurements)\n  }\n\n  _pushToChart(measurements) {\n    this.metric.handleMeasurements(measurements)\n  }\n\n  // clears the buffer and pushes the measurements\n  _flushToChart() {\n    let measurements = this._flushBuffer()\n    if (!measurements.length) { return }\n    this._pushToChart(measurements)\n  }\n\n  // clears and returns the buffered data as a flat array\n  _flushBuffer() {\n    if (this._buffer && !this._buffer.length) { return [] }\n    let measurements = this._buffer\n    this._buffer = []\n    return measurements.reduce((acc, val) => acc.concat(val), [])\n  }\n}\n\n/** LiveView Hook **/\n\nconst PhxChartComponent = {\n  mounted() {\n    let chartEl = this.el.parentElement.querySelector('.chart')\n    let size = chartEl.getBoundingClientRect()\n    let options = Object.assign({}, chartEl.dataset, {\n      tagged: (chartEl.dataset.tags && chartEl.dataset.tags !== \"\") || false,\n      width: Math.max(size.width, minChartSize.width),\n      height: minChartSize.height,\n      now: new Date() / 1e3,\n      refreshInterval: 1000\n    })\n\n    this.chart = new TelemetryChart(chartEl, options)\n\n    window.addEventListener(\"resize\", throttle(() => {\n      let newSize = chartEl.getBoundingClientRect()\n      this.chart.resize(newSize)\n    }))\n  },\n  updated() {\n    const data = Array\n      .from(this.el.children || [])\n      .map(({ dataset: { x, y, z } }) => {\n        // converts y-axis value (z) to number,\n        // converts timestamp (z) from \u00B5s to fractional seconds\n        return { x, y: +y, z: +z / 1e6 }\n      })\n\n    if (data.length > 0) {\n      this.chart.pushData(data)\n    }\n  },\n  destroyed() {\n    this.chart.clearTimers()\n  }\n}\n\nexport default PhxChartComponent\n", "/** LiveView Hook **/\n\nconst setCookie = (params) => {\n  let cookie = `${params.key}=${params.value};path=/`\n  if (window.location.protocol === \"https:\") {\n    cookie += `;samesite=strict`\n  }\n  if (params.domain) {\n    cookie += `;domain=${params.domain}`\n  }\n  document.cookie = cookie\n}\n\nconst removeCookie = (params) => {\n  const pastDate = 'Thu, 01 Jan 1970 00:00:00 GMT'\n  document.cookie = `${params.key}=; expires=${pastDate}`\n}\n\nconst isCookieEnabled = (hook) => {\n  return hook.el.hasAttribute('data-cookie-enabled')\n}\n\nconst cookieParams = (hook) => {\n  return {\n    key: hook.el.getAttribute('data-cookie-key'),\n    value: hook.el.getAttribute('data-cookie-value'),\n    domain: hook.el.getAttribute('data-cookie-domain')\n  }\n}\n\nconst PhxRequestLoggerCookie = {\n  updated() {\n    const loggerCookieParams = cookieParams(this)\n    removeCookie(loggerCookieParams)\n\n    if (isCookieEnabled(this)) {\n      setCookie(loggerCookieParams)\n    }\n  },\n}\n\nexport default PhxRequestLoggerCookie\n", "/** LiveView Hook **/\n\nconst copyToClipboard = (textarea) => {\n    if (!navigator.clipboard){\n      // Deprecated clipboard API\n      textarea.select()\n      textarea.setSelectionRange(0, 99999)\n      document.execCommand('copy')\n    } else {\n      // Modern Clipboard API\n      const text = textarea.value\n      navigator.clipboard.writeText(text)\n    }\n  }\n\nconst PhxRequestLoggerQueryParameter = {\n  mounted() {\n    this.el.querySelector('.btn-primary').addEventListener('click', e => {\n      const textarea = this.el.querySelector('textarea')\n      copyToClipboard(textarea)\n      const copyIndicator = this.el.querySelector('.copy-indicator')\n      copyIndicator.setAttribute('data-enabled', 'false')\n      void copyIndicator.offsetWidth // Resets the animation to ensure it will be played again\n      copyIndicator.setAttribute('data-enabled', 'true')\n    })\n  }\n}\n\nexport default PhxRequestLoggerQueryParameter\n", "/** LiveView Hook **/\n\nconst PhxRequestLoggerMessages = {\n  updated() {\n    if (this.el.querySelector('.logger-autoscroll-checkbox').checked) {\n      const messagesElement = this.el.querySelector('#logger-messages')\n      messagesElement.scrollTop = messagesElement.scrollHeight\n    }\n  }\n}\n\nexport default PhxRequestLoggerMessages\n", "const interactiveItemSelector = '.progress-bar, .color-bar-legend-entry'\nlet highlightedElementName\n\nconst highlightElements = (containerElement) => {\n  containerElement.querySelectorAll(interactiveItemSelector).forEach((progressBarElement) => {\n    if(highlightedElementName) {\n      const isMuted = progressBarElement.getAttribute('data-name') !== highlightedElementName\n\n      progressBarElement.setAttribute('data-muted', isMuted)\n    } else {\n      progressBarElement.removeAttribute('data-muted')\n    }\n  })\n}\n\nconst PhxColorBarHighlight = {\n  mounted() {\n    this.el.setAttribute('data-highlight-enabled', 'true')\n    this.el.querySelectorAll(interactiveItemSelector).forEach((progressBarElement) => (\n      progressBarElement.addEventListener('click', e => {\n        const name = e.currentTarget.getAttribute('data-name')\n        highlightedElementName = name === highlightedElementName ? null : name\n        highlightElements(this.el)\n      })\n    ))\n  },\n\n  updated() {\n    this.el.setAttribute('data-highlight-enabled', 'true')\n    highlightElements(this.el)\n  }\n}\n\nexport default PhxColorBarHighlight\n", "const REFRESH_DATA_COOKIE = \"_refresh_data\";\n\n/**\n * Stores refresh data in the `\"refresh_data\"` cookie.\n */\nexport function storeRefreshData(refreshData, path) {\n  const json = JSON.stringify(refreshData);\n  const encoded = encodeBase64(json);\n  setCookie(REFRESH_DATA_COOKIE, encoded, path, 157680000); // 5 years\n}\n\n/**\n * Loads refresh data from the `\"refresh_data\"` cookie.\n */\nexport function loadRefreshData() {\n  const encoded = getCookieValue(REFRESH_DATA_COOKIE);\n  if (encoded) {\n    const json = decodeBase64(encoded);\n    return JSON.parse(json);\n  } else {\n    return null;\n  }\n}\n\nfunction getCookieValue(key) {\n  const cookie = document.cookie\n    .split(\"; \")\n    .find((cookie) => cookie.startsWith(`${key}=`));\n\n  if (cookie) {\n    const value = cookie.replace(`${key}=`, \"\");\n    return value;\n  } else {\n    return null;\n  }\n}\n\nfunction setCookie(key, value, path, maxAge) {\n  const cookie = `${key}=${value};max-age=${maxAge};path=${path}`;\n  document.cookie = cookie;\n}\n\nfunction encodeBase64(string) {\n  return btoa(unescape(encodeURIComponent(string)));\n}\n\nfunction decodeBase64(binary) {\n  return decodeURIComponent(escape(atob(binary)));\n}\n", "/** LiveView Hook **/\n\nimport { storeRefreshData, loadRefreshData } from \"../refresh\";\n\nconst PhxRememberRefresh = {\n  updated() {\n    let config = loadRefreshData() || {};\n    config[this.el.dataset.page] = this.el.value\n    storeRefreshData(config, this.el.dataset.dashboardMountPath);\n  }\n}\n\nexport default PhxRememberRefresh\n"],
  "mappings": "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",
  "names": []
}
